---
title: 字符串
date: 2021-06-29 16:14:43
tags: [leetcode,字符串]
---

#### [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

*思路：对每个字符串，转为char数组，再将其排序，转为String后，存储于Map当中*

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        HashMap<String,List<String>> map = new HashMap<>();
        for(String str:strs){
            char[] chrs = str.toCharArray();
            Arrays.sort(chrs);
            String tmp = Arrays.toString(chrs);
            List<String> ll = map.getOrDefault(tmp,new ArrayList<>());
            ll.add(str);
            if(!map.containsKey(tmp)){
                map.put(tmp,ll);
            }
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

#### [Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

思路：按理说是一个26进制题，但是26时，应该输出`z`，1时应该输出'A'，$26\%26==0$，这样就没办法对齐，因此需要每轮对其减一，这样`0-25=>A-Z`

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder sb = new StringBuilder();
        while(columnNumber > 0){
            columnNumber --; // 减1后，0-25就可以对应'A'-'Z'
            sb.append((char)('A'+columnNumber % 26));
            columnNumber/=26;
        }
        return sb.reverse().toString();
    }
}
```

#### [字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

思路：

本题的字符串，形式很像一颗递归树，因此自然而然想到用DFS去解决，逐层地剥开，拿出子串，重复相同的操作，直至最后的结果。
以abc3[a2[c]]100b为例子：

1. 首先遍历到字符类型，我们将其直接加入到结果字符串当中
2. 如果是数字类型字符，则需要往下遍历，直到非数字字符，这样是为了拿到像100这样的情况出现
3. 拿到数字字符后，需要将其子串取出，本质上是栈的思想，但本题中'['']'肯定是成对出现的，那么我们统计这两个的次数，如[a2[c]]，设置初值flag=1，表示出现一个'['，从a开始遍历，当出现'['则flag自增，出现']'则自减，当flag==1时，表示我们的子串的位置已经拿到，直接重复1、2、3操作即可

```java
class Solution {
    public String decodeString(String s) {
        return dfs(s,0,s.length());
    }
    public String dfs(String str,int start,int end){
        StringBuilder res = new StringBuilder();
        for(int i=start;i<end;){
            char ch = str.charAt(i);
            if(Character.isDigit(ch)){
                int cnt = 1;
                StringBuilder num = new StringBuilder();
                while(Character.isDigit(str.charAt(i))){ // 找到连续的数字字符
                    ch = str.charAt(i);
                    num.append(ch);
                    i++;
                }
                int j = i+1;
                while(cnt > 0){ // 找到子串，如3[a2[c]]，则子串为a2[c]，无需使用栈，只需要计数"[""]"即可
                    char tmp = str.charAt(j);
                    if(tmp == ']') cnt --;
                    else if(tmp == '[') cnt ++;
                    j++;
                }
                String r = dfs(str,i+1,j-1); // 递归处理子串
                int x = str2int(num.toString());
                for(int k=0;k<x;k++){ // 子串需要重复若干次
                    res.append(r);
                }
                i = j;
            } else { // 非数字，如abc3[c]，则abc直接加入即可
                res.append(ch);
                i++;
            }
        }
        return res.toString();
    }
    public int str2int(String s){
        int num = 1;
        int cnt = 0;
        for(int i=s.length()-1;i>=0;i--){
            int tmp = s.charAt(i) - '0';
            cnt += tmp * num;
            num *= 10;
        }
        return cnt;
    }
}
```




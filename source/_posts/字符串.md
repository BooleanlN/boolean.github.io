---
title: 字符串
date: 2021-06-29 16:14:43
tags: [leetcode,字符串]
---

#### [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

*思路：对每个字符串，转为char数组，再将其排序，转为String后，存储于Map当中*

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        HashMap<String,List<String>> map = new HashMap<>();
        for(String str:strs){
            char[] chrs = str.toCharArray();
            Arrays.sort(chrs);
            String tmp = Arrays.toString(chrs);
            List<String> ll = map.getOrDefault(tmp,new ArrayList<>());
            ll.add(str);
            if(!map.containsKey(tmp)){
                map.put(tmp,ll);
            }
        }
        return new ArrayList<List<String>>(map.values());
    }
}
```

#### [Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

思路：按理说是一个26进制题，但是26时，应该输出`z`，1时应该输出'A'，$26\%26==0$，这样就没办法对齐，因此需要每轮对其减一，这样`0-25=>A-Z`

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder sb = new StringBuilder();
        while(columnNumber > 0){
            columnNumber --; // 减1后，0-25就可以对应'A'-'Z'
            sb.append((char)('A'+columnNumber % 26));
            columnNumber/=26;
        }
        return sb.reverse().toString();
    }
}
```

#### [字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

思路：

本题的字符串，形式很像一颗递归树，因此自然而然想到用DFS去解决，逐层地剥开，拿出子串，重复相同的操作，直至最后的结果。
以abc3[a2[c]]100b为例子：

1. 首先遍历到字符类型，我们将其直接加入到结果字符串当中
2. 如果是数字类型字符，则需要往下遍历，直到非数字字符，这样是为了拿到像100这样的情况出现
3. 拿到数字字符后，需要将其子串取出，本质上是栈的思想，但本题中'['']'肯定是成对出现的，那么我们统计这两个的次数，如[a2[c]]，设置初值flag=1，表示出现一个'['，从a开始遍历，当出现'['则flag自增，出现']'则自减，当flag==1时，表示我们的子串的位置已经拿到，直接重复1、2、3操作即可

```java
class Solution {
    public String decodeString(String s) {
        return dfs(s,0,s.length());
    }
    public String dfs(String str,int start,int end){
        StringBuilder res = new StringBuilder();
        for(int i=start;i<end;){
            char ch = str.charAt(i);
            if(Character.isDigit(ch)){
                int cnt = 1;
                StringBuilder num = new StringBuilder();
                while(Character.isDigit(str.charAt(i))){ // 找到连续的数字字符
                    ch = str.charAt(i);
                    num.append(ch);
                    i++;
                }
                int j = i+1;
                while(cnt > 0){ // 找到子串，如3[a2[c]]，则子串为a2[c]，无需使用栈，只需要计数"[""]"即可
                    char tmp = str.charAt(j);
                    if(tmp == ']') cnt --;
                    else if(tmp == '[') cnt ++;
                    j++;
                }
                String r = dfs(str,i+1,j-1); // 递归处理子串
                int x = str2int(num.toString());
                for(int k=0;k<x;k++){ // 子串需要重复若干次
                    res.append(r);
                }
                i = j;
            } else { // 非数字，如abc3[c]，则abc直接加入即可
                res.append(ch);
                i++;
            }
        }
        return res.toString();
    }
    public int str2int(String s){
        int num = 1;
        int cnt = 0;
        for(int i=s.length()-1;i>=0;i--){
            int tmp = s.charAt(i) - '0';
            cnt += tmp * num;
            num *= 10;
        }
        return cnt;
    }
}
```

#### [翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。

思路：根据题目说明，我们需要先过滤掉两边的空格，然后，再从尾到头收集单词

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder res = new StringBuilder();
        int end = s.length() - 1, start = 0;
        while (start < s.length()) {
            char ch = s.charAt(start);
            if (ch != ' ') break;
            start ++;
        }
        while (end >= 0) {
            char ch = s.charAt(end);
            if (ch != ' ') break;
            end --;
        }
        int endTemp = end+1;
        for(;end>=start;end--){
            char ch = s.charAt(end);
            if(' ' == ch) {
                if(endTemp - end > 1) {
                    res.append(s, end+1, endTemp);
                    res.append(" ");
                }
                endTemp = end;
            }
        }
        if (endTemp - end > 1) {
            res.append(s, end+1, endTemp);
        }
        return res.toString();
    }
}
```

#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

题解：

左右指针，滑动窗口，使用set统计字符，如果重复，则从重复的字符再开始继续统计。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int start = 0, n = s.length();
        char[] chars = s.toCharArray();
        Set<Character> srt = new HashSet<>();
        int left = 0, right = 0, maxLength = 0;
        while(right < n) {
            char ch = chars[right];
            if(srt.contains(ch)) {
                // maxLength = Math.max(maxLength, right - left);
                while(true) {
                    char ct = chars[left++];
                    srt.remove(ct);
                    if(ct == ch) break;
                }
            }
            srt.add(ch);
            right ++;
            maxLength = Math.max(maxLength, right - left);
        }
        return maxLength;
    }
}
```


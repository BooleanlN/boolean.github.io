---
title: 动态规划
date: 2021-06-23 15:40:24
tags: [leetcode,动态规划]
---

#### [组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

*思路：该题目回溯是不行的，会超时，考虑到`target=k`的状态与`target=k-nums[i]`的状态相关，可以用动态规划来做。*

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1]; // dp表示target=i的方案数
        dp[0] = 1; // target=0的方案数为1，表示不选取元素
        int idx = 1;
        while(idx <= target){
            for(int i=0;i<nums.length;i++){
                if(idx - nums[i] >= 0){
                    dp[idx] += dp[idx-nums[i]]; // 当前idx的方案数等于满足idx-nums[i]的方案数之和
                }   
            }
            // System.out.println(dp[idx]);
            idx++;
        }
        return dp[target];
    }
}
```

#### [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

*思路：记录最低点，每次算差值，得到最大的差值*

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int buy = 0;
        for(int i=0;i<prices.length;i++){
            if(prices[i]<prices[buy]){
                buy = i; // buy，保存[0,i]最低点
            } else{
                res = Math.max(prices[i] - prices[buy],res); // 不是最低点则计算差值
            }
        }
        return res;
    }
}
```

#### [最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gry15qsarlj30b808yglt.jpg)

思路：画了下图，假设从右下角开始，往上，往左扩散，可以发现，（i，j）能构成多大的正方形与它的右、下以及右下有关，因此，设置转移方程：

​							$dp((i,j)) = min(dp(i+1,j),dp(i,j+1),dp(i+1,j+1)) + 1$

如果$(i,j)==0$，则dp也为0.

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        int n = matrix.length-1, m = matrix[0].length-1;
        int[][] maxL = new int[n+1][m+1];
        for(int i=n;i>=0;i--){
            for(int j=m;j>=0;j--){
                if(i == n || j==m){
                    maxL[i][j] = matrix[i][j] == '1' ? 1 : 0;
                    max = Math.max(max,maxL[i][j]);
                    continue;
                }
                if(matrix[i][j] == '0') {
                    maxL[i][j] = 0;
                    continue;
                }
                int minTmp = Math.min(maxL[i+1][j],maxL[i][j+1]);
                minTmp = Math.min(maxL[i+1][j+1],minTmp);
                maxL[i][j] = minTmp+1;
                max = Math.max(max,maxL[i][j]);
            }
        }
        return max*max;
    }
}
```

#### [比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

思路：

*保留高位有效位，看下题解吧😓*

```java
class Solution {
    public int[] countBits(int n) {
        int cnt = 0;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        int highBit = 1; // 记录高有效位，比如1，2，4，8，16等
        for(int i=2;i<=n;i++){
            int tmp = i & (i-1);
            if(tmp == 0){
                highBit = i;
            }
            // (00,01,10,11) => (100,101,110,111) => (1000,1001,1010,1011,1100,1101,1110,1111)
            dp[i] = dp[i-highBit] + 1; 
        }
        return dp;
    }
}
```

#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

*思路：因为一个子串`(left,right)`是否是子串，与`(left+1,right-1)`是否是子串相关，因此考虑使用DP记忆`(i,j)`之间的串是否是回文。*

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        char[] chs = s.toCharArray();
        boolean[][] dp = new boolean[n][n];// i~j是否回文
        int left = 0, right = 0, maxLen = 1;
        for(int i=0;i<n;i++) dp[i][i] = true; // 单字符肯定是
        for(int col=0;col<n;col++){
            for(int row=0;row<col;row++){
                if(col-row==1){ // 两个挨着相同则是回文，否则不是
                    dp[row][col] =  s.charAt(col)==s.charAt(row);
                } else if(s.charAt(col)==s.charAt(row)){ // 如果相等，就判断回缩一格看是否是回文
                    dp[row][col] = dp[row+1][col-1];
                }
                if(dp[row][col]){ // 是回文就统计下长度
                    if(col - row + 1 > maxLen){
                        maxLen = col - row + 1;
                        left = row;
                        right = col;
                    }
                }
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(dp[i][j] + " ");
        //     }
        //     System.out.println();
        // }
        return s.substring(left,right+1);
    }
}
```

#### [回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

*思路：同上一题*

```java
class Solution {
    public int countSubstrings(String s) {
        int cnt = 0;
        int n = s.length();
        char[] chs = s.toCharArray();
        boolean[][] dp = new boolean[n][n];// i~j是否回文
        int left = 0, right = 0, maxLen = 1;
        cnt += n;
        for(int i=0;i<n;i++) dp[i][i] = true; // 单字符肯定是
        for(int col=0;col<n;col++){
            for(int row=0;row<col;row++){
                if(col-row==1){ // 两个挨着相同则是回文，否则不是
                    dp[row][col] =  s.charAt(col)==s.charAt(row);
                } else if(s.charAt(col)==s.charAt(row)){ // 如果相等，就判断回缩一格看是否是回文
                    dp[row][col] = dp[row+1][col-1];
                }
                if(dp[row][col]){ // 是回文就统计下长度
                    cnt ++;
                }
            }
        }
        return cnt;
    }
}
```

#### [打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

思路：

考虑当我偷到第`n`个屋子，我当前能拿到的最大的金额是多少呢？

1. 我偷当前屋子。Max = money[n] + maxMoney(n-2);
2. 我不偷当前屋子，金额就是第`n-1`的屋子的金额

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1)return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        int max = 0;
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i=2;i<n;i++){
            dp[i] = Math.max(dp[i-1],nums[i] + dp[i-2]);
        }
        return dp[n-1];
    }
}
```

#### [打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

思路：

该题目头尾连在一起，那么其实和上一题相比，中间的没有受到影响，而最后一个节点要求不包含第一个节点的最大值，所以就搞了另外一个dp来记录[1,n-1]的最大值，结尾要么就是

1. 不选第一间房+最后一间房（加不加由最大值定）
2. 选第一间房，不加最后一间房

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1)return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        if(n == 2) return dp[1];
        int[] dp2 = new int[n-1];
        dp2[0] = nums[1];
        dp2[1] = Math.max(nums[1],nums[2]);
        for(int i=2;i<n;i++){
            if(i > 2 && i == n-1){
                dp[i] = Math.max(dp2[i-2],nums[i] + dp2[i-3]); // 不选第一间房
                dp[i] = Math.max(dp[i-1],dp[i]); // 不选最后一间房
            }else if (i == 2 && i == n-1){
                dp[i] = Math.max(dp[i-1],nums[i]);
            } else {
                dp[i] = Math.max(dp[i-1],nums[i] + dp[i-2]);
                if (i > 2){
                    dp2[i-1] = Math.max(dp2[i-2],nums[i] + dp2[i-3]);
                }
            }
        }
        return dp[n-1];
    }
}
```

```java
class Solution {
    public int rob(int[] nums) {
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        } else if (length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));
    }

    public int robRange(int[] nums, int start, int end) {
        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```

#### [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

思路：

因为直接相连的房子不可以同时访问，因此，该题目下如何得到子节点与父节点之间最大值关系是最重要的。

考虑该节点访问和不访问两种情况，可以得到两种与子节点的关系：
$$
访问的情况：f(root) = root.val + g(left) + g(right) \ \  \\
不访问的情况：g(root) = max(f(left),g(left)) + max(f(right),g(right)) \ \ \\
$$

```java
class Solution {
    HashMap<TreeNode,Integer> f;
    HashMap<TreeNode,Integer> g;
    public int rob(TreeNode root) {
        if(root == null)return 0;
        f = new HashMap<>();
        g = new HashMap<>();
        dfs(root);
        return Math.max(f.get(root),g.get(root));
    }
    public void dfs(TreeNode root){
        if(root == null) return;
        if(root.left == null && root.right == null){
            f.put(root,root.val); // 选择该node
            g.put(root,0); // 不选择该node
            return;
        }
        dfs(root.left);
        dfs(root.right);
        int gl = g.getOrDefault(root.left,0), gr = g.getOrDefault(root.right,0);
        int fl = f.getOrDefault(root.left,0), fr = f.getOrDefault(root.right,0);
        f.put(root,root.val + gl+gr);
        g.put(root,Math.max(fl,gl) + Math.max(fr,gr));
    }
}
```

#### [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。

```java
class Solution {
    public int fib(int n) {
        if(n==0||n==1)return n;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

#### [第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

```java
class Solution {
    public int tribonacci(int n) {
        if(n==0||n==1)return n;
        if(n==2) return 1;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3;i<=n;i++){
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }
        return dp[n];
    }
}
```
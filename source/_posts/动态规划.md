---
title: 动态规划
date: 2021-06-23 15:40:24
tags: [leetcode,动态规划]
---

#### [组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

*思路：该题目回溯是不行的，会超时，考虑到`target=k`的状态与`target=k-nums[i]`的状态相关，可以用动态规划来做。*

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1]; // dp表示target=i的方案数
        dp[0] = 1; // target=0的方案数为1，表示不选取元素
        int idx = 1;
        while(idx <= target){
            for(int i=0;i<nums.length;i++){
                if(idx - nums[i] >= 0){
                    dp[idx] += dp[idx-nums[i]]; // 当前idx的方案数等于满足idx-nums[i]的方案数之和
                }   
            }
            // System.out.println(dp[idx]);
            idx++;
        }
        return dp[target];
    }
}
```

#### [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

*思路：记录最低点，每次算差值，得到最大的差值*

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int buy = 0;
        for(int i=0;i<prices.length;i++){
            if(prices[i]<prices[buy]){
                buy = i; // buy，保存[0,i]最低点
            } else{
                res = Math.max(prices[i] - prices[buy],res); // 不是最低点则计算差值
            }
        }
        return res;
    }
}
```

#### [最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gry15qsarlj30b808yglt.jpg)

思路：画了下图，假设从右下角开始，往上，往左扩散，可以发现，（i，j）能构成多大的正方形与它的右、下以及右下有关，因此，设置转移方程：

​							$dp((i,j)) = min(dp(i+1,j),dp(i,j+1),dp(i+1,j+1)) + 1$

如果$(i,j)==0$，则dp也为0.

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int max = 0;
        int n = matrix.length-1, m = matrix[0].length-1;
        int[][] maxL = new int[n+1][m+1];
        for(int i=n;i>=0;i--){
            for(int j=m;j>=0;j--){
                if(i == n || j==m){
                    maxL[i][j] = matrix[i][j] == '1' ? 1 : 0;
                    max = Math.max(max,maxL[i][j]);
                    continue;
                }
                if(matrix[i][j] == '0') {
                    maxL[i][j] = 0;
                    continue;
                }
                int minTmp = Math.min(maxL[i+1][j],maxL[i][j+1]);
                minTmp = Math.min(maxL[i+1][j+1],minTmp);
                maxL[i][j] = minTmp+1;
                max = Math.max(max,maxL[i][j]);
            }
        }
        return max*max;
    }
}
```

#### [比特位计数](https://leetcode-cn.com/problems/counting-bits/)

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

思路：

*保留高位有效位，看下题解吧😓*

```java
class Solution {
    public int[] countBits(int n) {
        int cnt = 0;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        int highBit = 1; // 记录高有效位，比如1，2，4，8，16等
        for(int i=2;i<=n;i++){
            int tmp = i & (i-1);
            if(tmp == 0){
                highBit = i;
            }
            // (00,01,10,11) => (100,101,110,111) => (1000,1001,1010,1011,1100,1101,1110,1111)
            dp[i] = dp[i-highBit] + 1; 
        }
        return dp;
    }
}
```

#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

*思路：因为一个子串`(left,right)`是否是子串，与`(left+1,right-1)`是否是子串相关，因此考虑使用DP记忆`(i,j)`之间的串是否是回文。*

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        char[] chs = s.toCharArray();
        boolean[][] dp = new boolean[n][n];// i~j是否回文
        int left = 0, right = 0, maxLen = 1;
        for(int i=0;i<n;i++) dp[i][i] = true; // 单字符肯定是
        for(int col=0;col<n;col++){
            for(int row=0;row<col;row++){
                if(col-row==1){ // 两个挨着相同则是回文，否则不是
                    dp[row][col] =  s.charAt(col)==s.charAt(row);
                } else if(s.charAt(col)==s.charAt(row)){ // 如果相等，就判断回缩一格看是否是回文
                    dp[row][col] = dp[row+1][col-1];
                }
                if(dp[row][col]){ // 是回文就统计下长度
                    if(col - row + 1 > maxLen){
                        maxLen = col - row + 1;
                        left = row;
                        right = col;
                    }
                }
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(dp[i][j] + " ");
        //     }
        //     System.out.println();
        // }
        return s.substring(left,right+1);
    }
}
```

#### [回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

*思路：同上一题*

```java
class Solution {
    public int countSubstrings(String s) {
        int cnt = 0;
        int n = s.length();
        char[] chs = s.toCharArray();
        boolean[][] dp = new boolean[n][n];// i~j是否回文
        int left = 0, right = 0, maxLen = 1;
        cnt += n;
        for(int i=0;i<n;i++) dp[i][i] = true; // 单字符肯定是
        for(int col=0;col<n;col++){
            for(int row=0;row<col;row++){
                if(col-row==1){ // 两个挨着相同则是回文，否则不是
                    dp[row][col] =  s.charAt(col)==s.charAt(row);
                } else if(s.charAt(col)==s.charAt(row)){ // 如果相等，就判断回缩一格看是否是回文
                    dp[row][col] = dp[row+1][col-1];
                }
                if(dp[row][col]){ // 是回文就统计下长度
                    cnt ++;
                }
            }
        }
        return cnt;
    }
}
```






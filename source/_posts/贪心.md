---
title: 贪心
date: 2021-07-03 19:58:45
tags: [leetcode,贪心]
---

#### [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

思路：

1. 一开始的思路是先按照`ki`值进行排序，然后，从0～n，按个去放：放第0个位置时，肯定是从`k=0`的去选，按照贪心原则选择最小的，其次，需要判断前面的数字是否满足ki个大于当前hi的，满足就放在优先队列，每一轮，取出一个，但这样的复杂度太高，O(n*n*logn)
2. 看了题解的思路，如下：

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从小到大排，如果身高相同，则按照k从大到小排序
        // 本解题思路是从小到大，将其前面的空预留，比如[4,4]，那么在它前面预留4个位置，把它放在第五个位置，
        // 当[6,1]时，前面需要预留一个空位置，忽视小于6的，预留一个空位置即可
        Arrays.sort(people, (person1, person2) -> {
            if (person1[0] != person2[0]) {
                return person1[0] - person2[0];
            } else {
                return person2[1] - person1[1];
            }
        });
        int n = people.length;
        int[][] ans = new int[n][];
        for(int[] person:people){
            int spaces = person[1] + 1;
            for(int i=0;i<n;i++){
                if (ans[i] == null){
                    spaces--;
                    if (spaces == 0){
                        ans[i] = person;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```

#### [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

思路：

1. 动态规划：

   本题考虑到n的完全平方数f(n)，与`f(n-k)+1`有关，也就是与子状态相关，考虑使用DP。

   $f(n) = Math.min(f(n-k) + 1),k=1,4,9,16...$

   时间复杂度为$O(n\sqrt{n})$

   ```java
   class Solution {
       public int numSquares(int n) {
           int[] dp = new int[n+1];
           dp[0] = 0;
           dp[1] = 1;
           for(int i=2;i<=n;i++){
               int tmp = 1;
               dp[i] = 10000;
               while(tmp*tmp <= i){
                   if (tmp*tmp == i){
                       dp[i] = 1;
                       break;
                   }
                   dp[i] = Math.min(dp[i],1 + dp[i-tmp*tmp]);
                   tmp++;
               }
           }
           return dp[n];
       }
   }
   ```

2. 贪心算法

   需要的数目从1到n，去判断能否组成，需要预设完全平方数列表。

   ```java
   class Solution {
       ArrayList<Integer> nums;
       public int numSquares(int n) {
           nums = new ArrayList<>();
           for(int i=1;i*i<=n;i++){
               nums.add(i*i);
           }
           for(int i=1;i<=n+1;i++){
               if(isValid(n,i)) return i;
           }
           return -1;
       }
       public boolean isValid(int n,int count){
           if(count == 1){
                   return nums.contains(n);
           }
           for(int num:nums){
               if(isValid(n-num,count-1)){
                   return true;
               }
           }
           return false;
       }
   }
   ```


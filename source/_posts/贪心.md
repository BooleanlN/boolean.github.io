---
title: 贪心
date: 2021-07-03 19:58:45
tags: [leetcode,贪心]
---

#### [根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

思路：

1. 一开始的思路是先按照`ki`值进行排序，然后，从0～n，按个去放：放第0个位置时，肯定是从`k=0`的去选，按照贪心原则选择最小的，其次，需要判断前面的数字是否满足ki个大于当前hi的，满足就放在优先队列，每一轮，取出一个，但这样的复杂度太高，O(n*n*logn)
2. 看了题解的思路，如下：

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从小到大排，如果身高相同，则按照k从大到小排序
        // 本解题思路是从小到大，将其前面的空预留，比如[4,4]，那么在它前面预留4个位置，把它放在第五个位置，
        // 当[6,1]时，前面需要预留一个空位置，忽视小于6的，预留一个空位置即可
        Arrays.sort(people, (person1, person2) -> {
            if (person1[0] != person2[0]) {
                return person1[0] - person2[0];
            } else {
                return person2[1] - person1[1];
            }
        });
        int n = people.length;
        int[][] ans = new int[n][];
        for(int[] person:people){
            int spaces = person[1] + 1;
            for(int i=0;i<n;i++){
                if (ans[i] == null){
                    spaces--;
                    if (spaces == 0){
                        ans[i] = person;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```


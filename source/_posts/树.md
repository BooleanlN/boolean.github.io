---
title: 树
date: 2021-06-15 16:51:51
tags: [leetcode,树]
---

#### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

有递归和非递归俩种方案：

```java
// 递归版本
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null)return res;
        inorderTraversal(root.left);
        res.add(root.val);
        inorderTraversal(root.right);
        return res;
    }
}
// 非递归版本
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null) return res;
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        while(root != null || !stack.isEmpty()){
            while(root != null){ // 将左子树结点都入栈
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root = root.right; // 转向右节点
        }
        return res;
    }
}
```

#### [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

*思路：DFS，递归地合并同位置节点*

```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null || root2 == null){
            return root1 == null ? root2 : root1;
        }
        root1.val = root1.val + root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    }
}
```

#### [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

思路：

使用栈结构进行前序遍历，并用`left`指针保存先序遍历顺序（因为左指针在访问完后就没用了，右指针后面访问右子树还有用）,之后左右指针调换下就行。

```java
class Solution {
    public void flatten(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode res = new TreeNode(-1),p = res;
        while(root != null || !stack.isEmpty()){ // 先序遍历
            while(root != null){
                p.left = root;
                p = root;
                stack.push(root);
                root = root.left;
            }
            if(!stack.isEmpty()){
                root = stack.pop();
                root = root.right;
            }
        }
        while(res != null){
            res.right = res.left;
            res.left = null;
            res = res.right;
        }
    }
}
```

#### [把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。

思路：

一开始想的复杂了，直接把中序遍历整出来，再一个个算。其实可以反序的中序遍历来做，这种的话，递归或者迭代，都可以，递归结果会快点。

```java
class Solution {
    int cnt = 0;
    public TreeNode convertBST(TreeNode root) {
        if(root == null) return null;
        if(root.right == null && root.left == null){
            cnt += root.val;
            root.val = cnt;
            return root;
        }
        convertBST(root.right);
        cnt += root.val;
        root.val = cnt;
        convertBST(root.left);
        return root;
    }
}
```

#### [皇位继承顺序](https://leetcode-cn.com/problems/throne-inheritance/)

题目太长，不复制了。

思路：转化为树，继承顺序可以用前序遍历

```java
class ThroneInheritance {
    private Map<String,List<String>> orders;
    private Set<String> dead;
    private String king;
    public ThroneInheritance(String kingName) {
        orders = new HashMap<>();
        orders.put(kingName,new ArrayList<>());
        dead = new HashSet<>();
        king = kingName;
    }
    
    public void birth(String parentName, String childName) {
        if(orders.containsKey(parentName)){
            List<String> childs = orders.get(parentName);
            childs.add(childName);
        } else {
            List<String> childs = new ArrayList<>();
            childs.add(childName);
            orders.put(parentName,childs);
        }
    }
    
    public void death(String name) {
        dead.add(name);
    }
    
    public List<String> getInheritanceOrder() {
        List<String> res = new ArrayList<>();
        preorder(king,res);
        return res;
    }
    public void preorder(String name,List<String> res){
        if(!dead.contains(name)){
            res.add(name);
        }
        List<String> childs = orders.getOrDefault(name,new ArrayList<>());
        for(String child:childs){
            preorder(child,res);
        }
    }
}
```

#### [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

*思路：使用DFS，比较左右子树大小，取其大。*

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return left > right ? left + 1 : right + 1;
    }
}	
```

#### [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

思路：

1. 中序遍历，判断递增关系

   ```java
   class Solution {
       public boolean isValidBST(TreeNode root) {
           Deque<TreeNode> stack = new LinkedList<>();
           int pre = -1,flag = 0;
           while(root!=null || !stack.isEmpty()){
               while(root != null){
                   stack.push(root);
                   root = root.left;
               }
               if(!stack.isEmpty()){
                   root = stack.pop();
                   if(flag == 1){
                       if(root.val <= pre) return false;
                       pre = root.val;
                   } else {
                       flag = 1;
                       pre = root.val;
                   }
                   root = root.right;
               }
           }
           return true;
       }
   }
   ```

2. 递归，设置区间

   ```java
   class Solution {
       public boolean isValidBST(TreeNode root) {
           if(root == null) return true;
           return helper(root,Long.MIN_VALUE, Long.MAX_VALUE);
       }
       public boolean helper(TreeNode root,long min,long max){
           if(root == null) return true;
           if(root.val >= max || root.val <= min) return false;
           return helper(root.left,min,root.val) && helper(root.right,root.val,max);
       }
   }
   ```

#### [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定一个二叉树，返回它的 后序 遍历。

思路：用栈，在弹出时，需要判断是否要输出：

- 当前节点无右子节点
- 上一个访问节点为其右子节点

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode pre = null;
        while(root != null || !stack.isEmpty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }
            if(!stack.isEmpty()){
                root = stack.pop();
                if(root.right == null || root.right == pre){ // 当前结点访问的上一结点是其右子节点 或者为叶子节点
                    res.add(root.val);
                    pre = root;
                    root = null; // 关键步骤，通过设置为null，可以跳过上边的遍历入栈，避免再次访问
                } else {
                    stack.push(root);
                    root = root.right;
                }
            }
        }
        return res;
    }
}
```

#### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转一棵二叉树。

*思路：左右交换，递归处理左右子树*

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

#### [路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

*思路：`[],0`时，需要返回`false`*

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        if(root.left == null && root.right == null && targetSum == root.val) return true;
        return hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);
    }
}
```

#### [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

*思路：思路与上题一致，只是要记录路径，使用List回溯*

```java
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        res = new ArrayList<>();
        dfs(root,targetSum,new LinkedList<>());
        return res;
    }
    public void dfs(TreeNode root,int targetSum,LinkedList<Integer> tmp){
        if(root == null)return;
        if(root.left == null && root.right == null && targetSum == root.val){
            tmp.add(root.val);
            res.add(new LinkedList<>(tmp));
            tmp.removeLast();
            return;
        }
        tmp.add(root.val);
        dfs(root.left,targetSum-root.val,tmp);
        dfs(root.right,targetSum-root.val,tmp);
        tmp.removeLast();
    }
}
```

#### [路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树，它的每个结点都存放着一个整数值。

找出路径和等于给定数值的路径总数。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。

```java
本题要求得从一个节点到另一个节点，之间的总和为target的path数量。
利用前缀和的思想，假设树型结构如下：


           1
         /   \
        2     3
      /  \.  /. \
    4     5 6    7
则4的前缀和为1 + 2 + 4 = 7
2的前缀和为1 + 2 = 3
那么，从节点4的路径上去掉节点2的路径的和，就是两者的前缀和之差
因此，通过设置一个Map，记录前缀和，每次遍历到结点时：

一方面判断从根节点到当前节点的路径是不是满足target
另一方面要判断是否存在中间的路径是target，这个就需要利用前缀和之差来做
此外，因为本题要求必须是从上到下的路径，因此在递归完自己的子树后，需要把自己的前缀和从map中删除，以防干扰其他非子树结点。
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res;
    public int pathSum(TreeNode root, int targetSum) {
        HashMap<Integer,Integer> preSum = new HashMap<>();
        dfs(root,0,targetSum,preSum);
        return res;
    }
    public void dfs(TreeNode root,int sum,int targetSum,HashMap<Integer,Integer> preSum ){
        if(root == null) return;
        sum += root.val;
        if(sum == targetSum) res ++;
        if(preSum.containsKey(sum - targetSum)){
            res += preSum.get(sum - targetSum);
        }
        int cnt = preSum.getOrDefault(sum,0);
        preSum.put(sum,++cnt);
        dfs(root.left,sum,targetSum,preSum);
        dfs(root.right,sum,targetSum,preSum);
        cnt = preSum.getOrDefault(sum,0);
        if(cnt == 0){
            preSum.remove(sum);
        } else {
            preSum.put(sum,--cnt);
        }
    }
}
```


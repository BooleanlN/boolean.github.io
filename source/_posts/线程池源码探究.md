---
title: 线程池源码探究
date: 2021-10-23 13:24:48
tags: [java, 面试]
---

### 线程池源码

#### 为什么需要线程池？

1. 提高线程利用率
2. 减少因为创建、销毁线程所带来的性能损耗
3. 提高吞吐量

#### 如何创建线程池？

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor()
```

并指定线程池的`corePoolSize`、`maximumPoolSize`、`keepAliveTime`、`unit`、`workQueue`、`threadFactory`、`handler`

#### 线程池执行逻辑？

首先介绍下线程池参数概念：

corePoolSize：核心线程数，线程池基本大小

maximumPoolSize：最大线程数，同一时刻内线程池中线程的数量最大阈值。

keepAliveTime：工作线程最大空闲时间，超过该空闲时间，工作线程将会被回收

unit：keepAliveTime的时间单位

wordQueue：任务队列，用来存放任务。

threadFactory：线程池创建工厂类（默认为`DefaultThreadFactory`）

handler：拒绝策略：

- AbortPolicy：拒绝，抛出异常（**默认策略**）
- CallerRunsPolicy：提交任务的线程自己处理
- DiscardPolicy：不处理，直接丢弃
- DiscardOldestPolicy：丢弃排在最前面的任务，并执行当前任务

#### 其它线程池相关术语

1. ThreadFactory

   线程工厂，用于线程池创建线程

   - ThreadGroup：线程组，一组方便管理的线程集合，整体呈树形关系，如下图（来源于网络）所示

     ![image-20211206160029819](https://tva1.sinaimg.cn/large/008i3skNgy1gx467chs4fj30ns0mmaar.jpg)

   - ThreadName

     线程名称，用于创建线程时，指定线程名称

   - Daemon

     是否为守护线程

   - Priority

     线程优先级

   以比较常用的`DefaultThreadFactory`为例：

   ```java
   static class DefaultThreadFactory implements ThreadFactory {
     			// 并发控制量，反映当前pool中创建的线程名称数量
           private static final AtomicInteger poolNumber = new AtomicInteger(1);
           private final ThreadGroup group;
     			// 并发控制量，反映当前pool中创建的线程数量
           private final AtomicInteger threadNumber = new AtomicInteger(1);
           private final String namePrefix;
   
           DefaultThreadFactory() {
              // 系统安全管理器，保证操作的安全性
               SecurityManager s = System.getSecurityManager();
               group = (s != null) ? s.getThreadGroup() :
                                     Thread.currentThread().getThreadGroup();
               namePrefix = "pool-" +
                             poolNumber.getAndIncrement() +
                            "-thread-";
           }
   		   // 重写的方法
           public Thread newThread(Runnable r) {
               Thread t = new Thread(group, r,
                                     namePrefix + threadNumber.getAndIncrement(),
                                     0);
             // 创建非守护线程  
             if (t.isDaemon())
                   t.setDaemon(false);
             // 创建线程优先级为NORM_PRIORITY
               if (t.getPriority() != Thread.NORM_PRIORITY)
                   t.setPriority(Thread.NORM_PRIORITY);
               return t;
           }
       }
   ```



#### 线程池实现源码

1. Worker工作线程类

   Worker类继承了AQS，目的是简化获取和释放任务执行时所需锁的操作。

   加锁的原因：

   1. 防止在运行过程中被中断

```java
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
{
  // 线程，默认为NULL，factory创建失败也为NULL
  final Thread thread;
  // 初始化任务
  Runnable firstTask;
  // 任务计数器
  volatile long completedTasks;
  
  Worker(Runnable firstTask) {
    setState(-1); // 禁止中断
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
  }
  // 
  public void run() {runWorker(this);}
  protected boolean isHeldExclusively() {return getState() != 0;}
  // 重写tryAcquire方法，CAS获取锁
  protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0, 1)) {
      setExclusiveOwnerThread(Thread.currentThread());
      return true;
    }
    return false;
  }
 // 重写AQS-tryRelease方法
  protected boolean tryRelease(int unused) {
    setExclusiveOwnerThread(null);
    setState(0);
    return true;
  }
  // 首先调用tryAcquire方法获取🔒，获取不到，则加入等待队列
  public void lock()        { acquire(1); }
  // 调用tryAcquire方法获取🔒，获取不到，返回false
  public boolean tryLock()  { return tryAcquire(1); }
  // 调用tryRelease，并唤醒后续线程
  public void unlock()      { release(1); }
  public boolean isLocked() { return isHeldExclusively(); }
  // 中断当前线程
  void interruptIfStarted() {
    Thread t;
    // state为-1时，不可中断
    if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
      try {
        t.interrupt();
      } catch (SecurityException ignore) {
      }
    }
  }
}
```

执行worker线程

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

2. 执行方法`execute`

```java
public void execute(Runnable command) {
  if (command == null)
      throw new NullPointerException();
  int c = ctl.get();
  // 1. 小于核心线程数，无论当前其它核心线程是否空闲，都创建新线程
  if (workerCountOf(c) < corePoolSize) {
    if (addWorker(command, true))
      return;
    c = ctl.get();
  }
  // 2. 大于核心线程数，则添加至阻塞队列
  if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    // 2.1 添加成功，检测线程池状态
    // 2.1.1 线程池关闭，则移走任务，走reject策略
    if (! isRunning(recheck) && remove(command))
      reject(command);
    // 2.1.2 当一个worker都没有时，则添加worker
    else if (workerCountOf(recheck) == 0)
      addWorker(null, false);
  }
  // 3. 队列满时，创建新线程执行，如果超出maximumPoolSize，则reject策略
  else if (!addWorker(command, false))
    reject(command); 
}
```

![image-20211023141607308](https://tva1.sinaimg.cn/large/008i3skNgy1gvp7x6wdp4j61qi0s8whx02.jpg)




---
title: 线程池源码探究
date: 2021-10-23 13:24:48
tags: [java, 面试]
---

### 线程池源码

#### 为什么需要线程池？

1. 提高线程利用率
2. 减少因为创建销毁线程所带来的性能损耗

#### 如何创建线程池？

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor()
```

指定线程池的`corePoolSize`、`maximumPoolSize`、`keepAliveTime`、`unit`、`workQueue`、`threadFactory`、`handler`

#### 线程池执行逻辑？

首先介绍下线程池参数概念：

corePoolSize：核心线程数，线程池基本大小

maximumPoolSize：最大线程数，同一时刻内线程池中线程的数量最大阈值。

keepAliveTime：工作线程最大空闲时间，超过该空闲时间，工作线程将会被回收

unit：keepAliveTime的时间单位

wordQueue：任务队列，用来存放任务。

threadFactory：线程池创建工厂类

handler：拒绝策略：

- AbortPolicy：拒绝，抛出异常
- CallerRunsPolicy：提交任务的线程自己处理
- DiscardPolicy：不处理，直接丢弃
- DiscardOldestPolicy：丢弃排在最前面的任务，并执行当前任务

#### 线程池实现源码

1. Worker工作线程类

```java
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
{
  
  final Thread thread;
  Runnable firstTask;
  volatile long completedTasks;
  
  Worker(Runnable firstTask) {
    setState(-1); 
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
  }
}
```

2. 执行方法`execute`

```java
public void execute(Runnable command) {
  if (command == null)
      throw new NullPointerException();
  int c = ctl.get();
  // 1. 小于核心线程数，则创建新线程
  if (workerCountOf(c) < corePoolSize) {
    if (addWorker(command, true))
      return;
    c = ctl.get();
  }
  // 2. 大于核心线程数，则添加至阻塞队列
  if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    // 2.1 添加成功，检测线程池状态
    // 2.1.1 线程池关闭，则移走任务，走reject策略
    if (! isRunning(recheck) && remove(command))
      reject(command);
    // 2.1.2 当一个worker都没有时，则添加worker
    else if (workerCountOf(recheck) == 0)
      addWorker(null, false);
  }
  // 3. 队列满时，创建新线程执行，如果超出maximumPoolSize，则reject策略
  else if (!addWorker(command, false))
    reject(command); 
}
```

![image-20211023141607308](https://tva1.sinaimg.cn/large/008i3skNgy1gvp7x6wdp4j61qi0s8whx02.jpg)




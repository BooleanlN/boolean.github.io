---
title: 数组
date: 2021-06-11 11:51:23
tags: [leetcode,数组]
---

#### 两数之和

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>(nums.length);
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target - nums[i])) return new int[]{map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

#### [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

*该题目不要陷到旋转90度里面，要多考虑怎么能够以更简单的方式旋转，也能够达到90度。*

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-i-1][j];
                matrix[n-i-1][j] = temp;
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(matrix[i][j] + " ");
        //     }
        //     System.out.println("");
        // }
        // 左对角线翻转
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(matrix[i][j] + " ");
        //     }
        //     System.out.println("");
        // }
    }
}
```

#### [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

*该题思路与“三数之和”、“四数之和”等一样，固定一个数，将其转化为两数之和即可。*

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length,res = 10001;
        for(int i=0;i<n;i++){
            int temp = nums[i]; // 固定一个数
            int L = i+1,R = n-1;
            while(L < R){ // 左右双指针，判断差值
                int x = temp + nums[L] + nums[R];
                int cha = x - target;
                if(Math.abs(cha) < Math.abs(res-target)){
                    res = x;
                }
                if( cha < 0){
                    L++;
                    while (L < R && nums[L] == nums[L-1]){ // 略过相同的值，减少次数
                        L ++;
                    }
                } else if(cha > 0){
                    R--;
                    while (L < R && nums[R] == nums[R+1]){ // 略过相同的值，减少次数
                        R--;
                    }
                } else {
                    return target;
                }
            }
        }
        return res;
    }
}
```

#### [子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

思路：

[1,2,3]子集，那么从空集开始，每加入一个元素，就在原基础上增加一组：

[]

[],[1]=[] + 1

[],[1],[2]=[]+2,[1,2] =[1]+2

[],[1],[2],[3]=[]+3,[1,3]=[1]+3,[2,3]=[2]+3,[1,2,3] = [1,2] + 3

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        for(int i=0;i<nums.length;i++){
            int size = res.size();
            for(int j=0;j<size;j++){
                List<Integer> x = res.get(j);
                List<Integer> tmp = new ArrayList<>(x);
                tmp.add(nums[i]);
                res.add(tmp);
            }
        }
        return res;
    }
}
```

#### [子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能**包含重复元素**，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

思路1：

本题与上一题目不同的在于会有重复元素，如何去重是本题要解决的问题。

假设[1,2,2]，按照上一题思路：

[]

[],[1]

[],[1],[2],[1,2]

在这一步，如果不加判断，会出现重复的：

[2],[1,2]，而先前有2的，可以再次添加2，不会出现重复。因此做法是判断当前是否重复，如若重复，则记录重复的长度值k，比如第二个2出现时，k = 1，那么在所有已加列表中，出现2的次数为1时，才新加入2，否则不加入，直接pass掉。

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<>());
        for(int i=0;i<nums.length;i++){
            int j = i,size = res.size();
            while(j>0&&nums[j]==nums[j-1]){ // 统计出现次数
                j --;
            }
            for(int k=0;k<size;k++){
                List<Integer> r = res.get(k);
                int num = 0;
                if(r.contains(nums[i])&& (i-j) > 0){
                    num = r.lastIndexOf(nums[i]) -  r.indexOf(nums[i]) + 1; // 已有的数目
                }
                List<Integer> tmp = new ArrayList<>(res.get(k));
                if(num == (i - j)){ // 出现次数想等，则可以新加入
                    tmp.add(nums[i]);
                    res.add(tmp);
                }
            }
        }
        return res;
    }
}
```

优化：看评论区后，其实[1,2,2]中，当2再次出现时，只会和len = 1，也就是上一步的长度相关，因此通过len，可以减少遍历次数

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<>());
        int len = 0;
        for(int i=0;i<nums.length;i++){
            int j = i,size = res.size(),left = 0;
            if(j>0&&nums[j]==nums[j-1]){ // res的左起点位置
               left = size - len;
            }
            len = size - left; 
            for(int k=left;k<size;k++){
                List<Integer> r = res.get(k);
                List<Integer> tmp = new ArrayList<>(res.get(k));
                tmp.add(nums[i]);
                res.add(tmp);
            }
        }
        return res;
    }
}
```

#### [找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。要求不使用额外空间且时间复杂度为 `O(n)`

*思路：使用原数组直接做标注，将当前元素对应下标位置到数扩大n，后面只要数哪些小于n即可。*

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n;i++){
            int idx = (nums[i]-1)%n;
            nums[idx] += n;
        }
        ArrayList<Integer> res = new ArrayList<>();
        for(int i=0;i<n;i++){
            if(nums[i] <= n){
                res.add(i+1);
            }
        }
        return res;
    }
}
```




---
title: 数组
date: 2021-06-11 11:51:23
tags: [leetcode,数组]
---

#### 两数之和

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>(nums.length);
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target - nums[i])) return new int[]{map.get(target-nums[i]),i};
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

#### [旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

*该题目不要陷到旋转90度里面，要多考虑怎么能够以更简单的方式旋转，也能够达到90度。*

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-i-1][j];
                matrix[n-i-1][j] = temp;
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(matrix[i][j] + " ");
        //     }
        //     System.out.println("");
        // }
        // 左对角线翻转
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         System.out.print(matrix[i][j] + " ");
        //     }
        //     System.out.println("");
        // }
    }
}
```

#### [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

*该题思路与“三数之和”、“四数之和”等一样，固定一个数，将其转化为两数之和即可。*

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length,res = 10001;
        for(int i=0;i<n;i++){
            int temp = nums[i]; // 固定一个数
            int L = i+1,R = n-1;
            while(L < R){ // 左右双指针，判断差值
                int x = temp + nums[L] + nums[R];
                int cha = x - target;
                if(Math.abs(cha) < Math.abs(res-target)){
                    res = x;
                }
                if( cha < 0){
                    L++;
                    while (L < R && nums[L] == nums[L-1]){ // 略过相同的值，减少次数
                        L ++;
                    }
                } else if(cha > 0){
                    R--;
                    while (L < R && nums[R] == nums[R+1]){ // 略过相同的值，减少次数
                        R--;
                    }
                } else {
                    return target;
                }
            }
        }
        return res;
    }
}
```

#### [子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

思路：

[1,2,3]子集，那么从空集开始，每加入一个元素，就在原基础上增加一组：

[]

[],[1]=[] + 1

[],[1],[2]=[]+2,[1,2] =[1]+2

[],[1],[2],[3]=[]+3,[1,3]=[1]+3,[2,3]=[2]+3,[1,2,3] = [1,2] + 3

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<Integer>());
        for(int i=0;i<nums.length;i++){
            int size = res.size();
            for(int j=0;j<size;j++){
                List<Integer> x = res.get(j);
                List<Integer> tmp = new ArrayList<>(x);
                tmp.add(nums[i]);
                res.add(tmp);
            }
        }
        return res;
    }
}
```

#### [子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能**包含重复元素**，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

思路1：

本题与上一题目不同的在于会有重复元素，如何去重是本题要解决的问题。

假设[1,2,2]，按照上一题思路：

[]

[],[1]

[],[1],[2],[1,2]

在这一步，如果不加判断，会出现重复的：

[2],[1,2]，而先前有2的，可以再次添加2，不会出现重复。因此做法是判断当前是否重复，如若重复，则记录重复的长度值k，比如第二个2出现时，k = 1，那么在所有已加列表中，出现2的次数为1时，才新加入2，否则不加入，直接pass掉。

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<>());
        for(int i=0;i<nums.length;i++){
            int j = i,size = res.size();
            while(j>0&&nums[j]==nums[j-1]){ // 统计出现次数
                j --;
            }
            for(int k=0;k<size;k++){
                List<Integer> r = res.get(k);
                int num = 0;
                if(r.contains(nums[i])&& (i-j) > 0){
                    num = r.lastIndexOf(nums[i]) -  r.indexOf(nums[i]) + 1; // 已有的数目
                }
                List<Integer> tmp = new ArrayList<>(res.get(k));
                if(num == (i - j)){ // 出现次数想等，则可以新加入
                    tmp.add(nums[i]);
                    res.add(tmp);
                }
            }
        }
        return res;
    }
}
```

优化：看评论区后，其实[1,2,2]中，当2再次出现时，只会和len = 1，也就是上一步的长度相关，因此通过len，可以减少遍历次数

```java
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        res.add(new ArrayList<>());
        int len = 0;
        for(int i=0;i<nums.length;i++){
            int j = i,size = res.size(),left = 0;
            if(j>0&&nums[j]==nums[j-1]){ // res的左起点位置
               left = size - len;
            }
            len = size - left; 
            for(int k=left;k<size;k++){
                List<Integer> r = res.get(k);
                List<Integer> tmp = new ArrayList<>(res.get(k));
                tmp.add(nums[i]);
                res.add(tmp);
            }
        }
        return res;
    }
}
```

#### [找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。要求不使用额外空间且时间复杂度为 `O(n)`

*思路：使用原数组直接做标注，将当前元素对应下标位置到数扩大n，后面只要数哪些小于n即可。*

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        for(int i=0;i<n;i++){
            int idx = (nums[i]-1)%n;
            nums[idx] += n;
        }
        ArrayList<Integer> res = new ArrayList<>();
        for(int i=0;i<n;i++){
            if(nums[i] <= n){
                res.add(i+1);
            }
        }
        return res;
    }
}
```

#### [组合总和](https://leetcode-cn.com/problems/combination-sum/)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

思路：该题目是组合问题，使用回溯进行解答，为了降低复杂度可以考虑排序等方法做剪枝。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); // 排序减少回溯次数
        List<Integer> t = new ArrayList<>();
        dfs(t,target,0,0,candidates);
        return res;
    }
    public void dfs(List<Integer> tmp, int target,int cnt,int idx,int[] candidates){
        if(cnt == target){
            res.add(new ArrayList<>(tmp));
            return;
        } else if(cnt > target) return;
        for(int i=idx;i<candidates.length;i++){ // 由于可以重复，因此这里需要使用
            if(cnt + candidates[i] > target) continue;
            tmp.add(candidates[i]);
            dfs(tmp,target,cnt + candidates[i],i,candidates);
            tmp.remove(tmp.size()-1); // 删除元素
        }
    }
}
```

#### [组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

思路：同样是数组，同样是回溯，这次要考虑如何去重

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates); // 排序减少回溯次数
        List<Integer> t = new ArrayList<>();
        dfs(t,target,0,0,candidates);
        return res;
    }
    public void dfs(List<Integer> tmp, int target,int cnt,int idx,int[] candidates){
        // System.out.println(tmp);
        if(cnt == target){
            res.add(new ArrayList<>(tmp));
            return;
        } else if(cnt > target) return;
        // cnt += candidates[idx];
        for(int i=idx;i<candidates.length;i++){
        // 去重逻辑：
        // [1,2,2,2,5]
        // 当选择[1,2]后，第三个2与第四个2会重复，因为两者处于同一调用栈，是否处于同一调用栈是通过`i>idx`来判断的，例如第2个2与第三个2就不是一个层级的调用栈
            if(i > idx && candidates[i] == candidates[i-1])continue;
            if(cnt + candidates[i] > target) continue;
            tmp.add(candidates[i]);
            dfs(tmp,target,cnt + candidates[i],i+1,candidates);
            tmp.remove(tmp.size()-1); // 删除元素
        }
    }
}
```

#### [组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 ***n*** 的 ***k\*** 个数的组合***。\***组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

思路：简单的回溯即可

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<Integer> t = new ArrayList<>();
        dfs(t,n,0,1,k);
        return res;
    }
    public void dfs(List<Integer> tmp, int target,int cnt,int idx,int k){
        if(tmp.size() > k) return;
        if(tmp.size() == k && cnt == target){
            res.add(new ArrayList<>(tmp));
            return;
        } else if(cnt > target) return;
        for(int i=idx;i<=9;i++){ 
           
            if(cnt + i > target) continue;
            tmp.add(i);
            dfs(tmp,target,cnt + i,i+1,k);
            tmp.remove(tmp.size()-1); // 删除元素
        }
    }
}
```

#### [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

*思路：首先排序后统计次数，然后采用优先队列（也就是堆）对数字进行排序，输出前k高。*

该题也可以使用块排思想，第一步统计完次数后，按照出现次数，采用快排把前k个输出。

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Arrays.sort(nums);
        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->a[1] - b[1] >= 0 ? -1:1);
        int cnt = 1;
        for(int i=0;i<nums.length;i++){
            if(i > 0 && nums[i]==nums[i-1]){
                cnt ++;
            } else if(i > 0 && nums[i] != nums[i-1]){
                queue.add(new int[]{nums[i-1],cnt});
                cnt = 1;
            }
        }
        queue.add(new int[]{nums[nums.length-1],cnt});
        int[] res = new int[k];
        int i=0;
        while(i < k){
            res[i] = queue.poll()[0];
            i++;
        }
        return res;
    }
}
```

#### [找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

- 字母异位词指字母相同，但排列不同的字符串。

*思路：使用滑动窗口，结合hash表，比较滑动窗口与给定p的差异*

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        HashMap<Character,Integer> windows = new HashMap<>();
        HashMap<Character,Integer> pChars = new HashMap<>();
        List<Integer> res = new ArrayList<>();
        int left = 0,right = 0, n = s.length(), m = p.length();
        for(int i=0;i<m;i++){
            char ch = p.charAt(i);
            if(pChars.containsKey(ch)){
                pChars.put(ch,pChars.get(ch) + 1);
            } else {
                pChars.put(ch,1);
            }
        }
        while(right < n){
            int len = right - left + 1;
            char ch = s.charAt(right);
            if(windows.containsKey(ch)){
                windows.put(ch,windows.get(ch) + 1);
            } else {
                windows.put(ch,1);
            }
            if(len < m){
                right ++;
            } else if(len == m){
                boolean match = compare(windows,pChars);
                if(match) res.add(left);
                ch = s.charAt(left);
                int cnt = windows.get(ch) - 1;
                if(cnt == 0) windows.remove(ch);
                else {
                    windows.put(ch,cnt);
                }
                left ++;
                right ++;
            }
        }
        return res;
    }
    private boolean compare(HashMap<Character,Integer> windows,HashMap<Character,Integer> pChars){
        for(char ch:pChars.keySet()){
            int a = pChars.get(ch); // 这里又个坑，因为Integer对[-128,127]做了cache，所以前面的值直接对比是没问题的，超出该区间，就需要用equals，或者拆包后再比较
            if(!windows.containsKey(ch) || a != windows.get(ch)){
                return false;
            }
        }
        return true;
    }
}
```

#### [多数元素](https://leetcode-cn.com/problems/majority-element/)

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

思路：

该类求众数的题目有个很好用的方法，叫**摩尔投票法**，就是说有n个候选人，n代表本题中的数字类别数目，如果当前`candidate == maj`，maj会支持自己，如果`candidate!=maj`，maj会联合其他人一起反对，最后，maj一定会当选。

其实我一开始的想法也是类似的，如果maj占了超过半数，那么他与其他票两两抵消，最后剩下的仍然是maj，但是没设计好，最后的方案其实和摩尔这个是一样的。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int candidates = 0, cnt = 0;
        for(int num:nums){
            if(cnt == 0){
                candidates = num;
                cnt += 1;
            }else if(candidates != num){ // 反对者
                cnt -= 1;
            } else { // 支持者
                cnt += 1;
            }
        }
        return candidates;
    }
}
```

#### [求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。

思路：摩尔投票法，进阶版。

*本次需要找出所有超出n/3的元素，那么最多可以出现2个候选人。那么还是一群人两两不相同就抵消，那么剩下的肯定是这两个（这两个之间不相互抵消）。*

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<>();
        int cand1 = nums[0],count1 = 0;
        int cand2 = nums[0],count2 = 0;
        for(int num:nums){
            if(cand1 == num){
                count1 ++;
            } else if(cand2 == num){
                count2 ++;
            } else if(count1 == 0){
                cand1 = num;
                count1 = 1;
            } else if(count2 == 0){
                cand2 = num;
                count2 = 1;
            } else{
                count1 --;
                count2 --;
            }
        }
        count1 = 0;
        count2 = 0;
        for(int num:nums){
            if(num == cand1) count1 ++;
            if(num == cand2) count2 ++;
        }
        if(count1 > nums.length / 3) res.add(cand1);
        if(count2 > nums.length / 3 && cand2 != cand1) res.add(cand2);
        return res;
    }
}
```

#### [最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 最短 子数组，并输出它的长度。

*思路：记录max、min值，找到min值应该在的位置start，记住最后一个乱序的值的位置end，end-start + 1即可*

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int max = nums[0],start = -1,end = -1,maxIdx = 0,min = 999999;
        for(int i=1;i<nums.length;i++){
            if(nums[i] < max){
                if(start == -1 || min > nums[i]) { // 找到最小元素应该在的位置
                    int tmp = maxIdx;
                    while(tmp >= 0 && nums[tmp] > nums[i]) tmp --;
                    start = tmp+1;
                    end = i;
                    min = nums[i];
                } else { // 更新结束位置
                    end = i;
                }
            } else if(nums[i] > max){ // 更新最大值与最大值位置（注：如果相同则跳过，23664，则跳过第二个6，因为4需要放到第一个6之前）
                max = nums[i];
                maxIdx = i;
            }
        }
        if(start == -1) return 0;
        return end - start + 1;
    }
}
```


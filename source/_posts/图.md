---
title: 图
date: 2021-06-28 13:49:53
tags: [leetcode,图]
---

#### [除法求值](https://leetcode-cn.com/problems/evaluate-division/)

给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

*思路：将`equations`转为图的连接，如果两个数字之间存在连接，那么就一定会有一个值，转为图之后，采用DFS、BFS都可以*

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        HashMap<String,Map> chars = new HashMap<>();
        int idx = 0;
        for(List<String> equation:equations){
            for(int i=0;i<2;i++){
                int k = i==0?1:0;
                String ch = equation.get(i);
                values[idx] = i==0?values[idx]:1/values[idx];
                Map<String,Double> m;
                if(chars.containsKey(ch)){
                    m = chars.get(ch);
                } else{
                    m = new HashMap<>();
                }
                m.put(equation.get(k),values[idx]);
                chars.put(ch,m);
            }
            idx ++;
        }
        double[] res = new double[queries.size()];
        idx = 0;
        for(List<String> query:queries){
            String a = query.get(0),b = query.get(1);
            if(!chars.containsKey(a)|| !chars.containsKey(b)){
                 res[idx++] = -1.0;
                 continue;
            }
            if(a.equals(b)) {
                res[idx++] = 1.0;
                continue;
            }
            Deque<String> stack = new LinkedList<>();
            HashMap<String,Double> ret = new HashMap<>();
            stack.push(a);
            ret.put(a,1.0);
            while(!stack.isEmpty() && !ret.containsKey(b)){
                String tmp = stack.pop();
                Map<String,Double> m = chars.get(tmp);
                for(String k:m.keySet()){
                    if(!ret.containsKey(k)){
                        stack.push(k);
                        ret.put(k,ret.get(tmp)*m.get(k));
                    }
                }
            }
            res[idx++] = ret.containsKey(b) ? ret.get(b) : -1.0;
        }
        return res;
    }
}
```

#### [课程表](https://leetcode-cn.com/problems/course-schedule/)

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

思路：典型的拓扑排序，方法一般有两种：

- BFS

  广度优先搜索，采用拓扑排序正向的处理方法，首先找出入度为0的点，然后，遍历这些点指向的点，将这些点的入度减一，循环此流程，直至所有节点都被访问，如果存在未被访问的节点，则表示存在环。无法形成拓扑排序

- DFS

  深度优先搜索，考虑设置三种状态，未访问、搜索中、搜索完成，任意选取点，从该点出发开始访问，并更改状态为搜索中。

  因为是深度优先搜索，因此一个节点的祖先节点都是要比它先访问到，因此会转为搜索中，但是该节点要比祖先节点先一步转为搜索完成。

  那么如果一个节点搜索中，发现其指向的节点出现了搜索中的状态，则表示访问到了其祖先节点，也就是出现了环。

  

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indeg = new int[numCourses];
        List<List<Integer>> edges = new ArrayList<>();
        for(int i=0;i<numCourses;i++){
            edges.add(new ArrayList<>());
        }
        for(int[] prerequisite:prerequisites){
            edges.get(prerequisite[1]).add(prerequisite[0]);
            indeg[prerequisite[0]] ++;
        }
        Deque<Integer> queue = new LinkedList<>();
        int cnt = 0;
        // 入度为0的点
        for(int i=0;i<numCourses;i++){
            if(indeg[i] == 0){
                queue.offer(i);
                cnt ++;
            }
        }
        
        while(!queue.isEmpty()){
            int node = queue.poll();
            List<Integer> ends = edges.get(node);
            for(int end:ends){
                // 入度减小
                indeg[end]--;
                if(indeg[end] == 0) { // 入度为0的进队列
                    queue.push(end);
                    cnt ++;
                }
            }
        }
        return cnt == numCourses;

    }
}
```

#### [课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

```java
class Solution {
    List<List<Integer>> edges;
    boolean res = true;
    List<Integer> path;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] visited = new int[numCourses];
        edges = new ArrayList<>();
        path = new ArrayList<>();
        for(int i=0;i<numCourses;i++){
            edges.add(new ArrayList<>());
        }
        for(int[] prerequisite:prerequisites){
            edges.get(prerequisite[1]).add(prerequisite[0]);
        }
        for(int i=0;i<numCourses;i++){
            if(visited[i] == 0){
                dfs(i,visited);
            }
        }
        if(res){
            int[] pathres = new int[numCourses];
            int idx = 0;
            for(int i=path.size()-1;i>=0;i--){
                pathres[idx++] = path.get(i);
            }
            return pathres;
        } 
        return new int[]{};
    }
    public void dfs(int node,int[] visited){
        visited[node] = 1;
        List<Integer> ll = edges.get(node);
        for(int t:ll){
            if(visited[t] == 0){
                dfs(t,visited);
                if(!res) return;
            } else if(visited[t] == 1) {
                res = false;
                return;
            }
        }
        visited[node] = 2;
        path.add(node);
    }
}
```
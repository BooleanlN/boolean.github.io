<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boolean</title>
  
  <subtitle>My Blog</subtitle>
  <link href="http://booleanln.github.io/myblog/atom.xml" rel="self"/>
  
  <link href="http://booleanln.github.io/myblog/"/>
  <updated>2021-11-28T12:17:57.063Z</updated>
  <id>http://booleanln.github.io/myblog/</id>
  
  <author>
    <name>Ning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-内存分配器</title>
    <link href="http://booleanln.github.io/myblog/2021/11/28/Redis-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://booleanln.github.io/myblog/2021/11/28/Redis-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</id>
    <published>2021-11-28T11:54:54.000Z</published>
    <updated>2021-11-28T12:17:57.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h2><p>分析下zmalloc.h、zmalloc.c两个文件源码。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><ol><li><p>内存分配器</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>USE_TCMALLOC<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">do</span> <span class="token expression">something with tcmalloc</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>USE_JEMALLOC<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">do</span> <span class="token expression">something with jemalloc</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__APPLE__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">do</span> <span class="token expression">something on Apple platform</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis提供了三种内存分配器选择，包括tcmalloc、jemalloc、Apple。</p></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *zmalloc(size_t size);void *zcalloc(size_t size);void *zrealloc(void *ptr, size_t size);void *ztrymalloc(size_t size);void *ztrycalloc(size_t size);void *ztryrealloc(void *ptr, size_t size);void zfree(void *ptr);void *zmalloc_usable(size_t size, size_t *usable);void *zcalloc_usable(size_t size, size_t *usable);void *zrealloc_usable(void *ptr, size_t size, size_t *usable);void *ztrymalloc_usable(size_t size, size_t *usable);void *ztrycalloc_usable(size_t size, size_t *usable);void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable);void zfree_usable(void *ptr, size_t *usable);char *zstrdup(const char *s);size_t zmalloc_used_memory(void);void zmalloc_set_oom_handler(void (*oom_handler)(size_t));size_t zmalloc_get_rss(void);int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);void set_jemalloc_bg_thread(int enable);int jemalloc_purge();size_t zmalloc_get_private_dirty(long pid);size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);size_t zmalloc_get_memory_size(void);void zlibc_free(void *ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存分配器&quot;&gt;&lt;a href=&quot;#内存分配器&quot; class=&quot;headerlink&quot; title=&quot;内存分配器&quot;&gt;&lt;/a&gt;内存分配器&lt;/h2&gt;&lt;p&gt;分析下zmalloc.h、zmalloc.c两个文件源码。&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="NoSQL" scheme="http://booleanln.github.io/myblog/tags/NoSQL/"/>
    
    <category term="Redis" scheme="http://booleanln.github.io/myblog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Whitening Sentence Representations for Better Semantics and Faster Retrieval</title>
    <link href="http://booleanln.github.io/myblog/2021/11/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Whitening-Sentence-Representations-for-Better-Semantics-and-Faster-Retrieval/"/>
    <id>http://booleanln.github.io/myblog/2021/11/27/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Whitening-Sentence-Representations-for-Better-Semantics-and-Faster-Retrieval/</id>
    <published>2021-11-27T07:52:07.000Z</published>
    <updated>2021-11-27T07:58:27.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Whitening-Sentence-Representations-for-Better-Semantics-and-Faster-Retrieval"><a href="#Whitening-Sentence-Representations-for-Better-Semantics-and-Faster-Retrieval" class="headerlink" title="Whitening Sentence Representations for Better Semantics and Faster Retrieval"></a>Whitening Sentence Representations for Better Semantics and Faster Retrieval</h2><p><a href="https://arxiv.org/search/cs?searchtype=author&query=Su,+J">Jianlin Su</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Cao,+J">Jiarun Cao</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Liu,+W">Weijie Liu</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Ou,+Y">Yangyiwen Ou</a></p><pre class="line-numbers language-none"><code class="language-none">@misc&#123;su2021whitening,      title&#x3D;&#123;Whitening Sentence Representations for Better Semantics and Faster Retrieval&#125;,       author&#x3D;&#123;Jianlin Su and Jiarun Cao and Weijie Liu and Yangyiwen Ou&#125;,      year&#x3D;&#123;2021&#125;,      eprint&#x3D;&#123;2103.15316&#125;,      archivePrefix&#x3D;&#123;arXiv&#125;,      primaryClass&#x3D;&#123;cs.CL&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考链接：<a href="https://kexue.fm/archives/8069">https://kexue.fm/archives/8069</a></p><p><a href="https://github.com/bojone/BERT-whitening">代码地址</a></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p><h3 id="Research-Objective-s"><a href="#Research-Objective-s" class="headerlink" title="Research Objective(s)"></a><strong>Research Objective(s)</strong></h3><h3 id="Background-Problem-Statement"><a href="#Background-Problem-Statement" class="headerlink" title="Background / Problem Statement"></a><strong>Background / Problem Statement</strong></h3><p>研究的背景以及问题陈述：作者需要解决的问题是什么？</p><h3 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a><strong>Method(s)</strong></h3><p>作者解决问题的方法/算法是什么？是否基于前人的方法？基于了哪些？</p><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><p>作者如何评估自己的方法？实验的setup是什么样的？感兴趣实验数据和结果有哪些？有没有问题或者可以借鉴的地方？</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h3><p>作者给出了哪些结论？哪些是strong conclusions, 哪些又是weak的conclusions（即作者并没有通过实验提供evidence，只在discussion中提到；或实验的数据并没有给出充分的evidence）?</p><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><p>(optional) 不在以上列表中，但需要特别记录的笔记。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><p>(optional) 列出相关性高的文献，以便之后可以继续track下去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Whitening-Sentence-Representations-for-Better-Semantics-and-Faster-Retrieval&quot;&gt;&lt;a href=&quot;#Whitening-Sentence-Representations-for-Bette</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Heterogeneous Graph Neural Networks for Extractive Document Summarization</title>
    <link href="http://booleanln.github.io/myblog/2021/11/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Heterogeneous-Graph-Neural-Networks-for-Extractive-Document-Summarization/"/>
    <id>http://booleanln.github.io/myblog/2021/11/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Heterogeneous-Graph-Neural-Networks-for-Extractive-Document-Summarization/</id>
    <published>2021-11-15T13:00:57.000Z</published>
    <updated>2021-11-25T09:10:26.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Heterogeneous-Graph-Neural-Networks-for-Extractive-Document-Summarization"><a href="#Heterogeneous-Graph-Neural-Networks-for-Extractive-Document-Summarization" class="headerlink" title="Heterogeneous Graph Neural Networks for Extractive Document Summarization"></a>Heterogeneous Graph Neural Networks for Extractive Document Summarization</h2><p><em>Danqing Wang∗, Pengfei Liu∗ ACL. 2020</em></p><pre class="line-numbers language-none"><code class="language-none">@misc&#123;wang2020heterogeneous,      title&#x3D;&#123;Heterogeneous Graph Neural Networks for Extractive Document Summarization&#125;,       author&#x3D;&#123;Danqing Wang and Pengfei Liu and Yining Zheng and Xipeng Qiu and Xuanjing Huang&#125;,      year&#x3D;&#123;2020&#125;,      eprint&#x3D;&#123;2004.12393&#125;,      archivePrefix&#x3D;&#123;arXiv&#125;,      primaryClass&#x3D;&#123;cs.CL&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://github.com/dqwang122/HeterSumGraph">代码地址</a></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><p>作者首次提出一种用于抽取式文本摘要刻画句子间关系的异构图，图中包含了<strong>词节点</strong>（基本语义单元）、<strong>句子结点</strong>（以及多文档摘要时用到的文档节点），词节点通过<strong>词嵌入</strong>做初始化，句子节点则通过<strong>CNN+BiLSTM</strong>抽取特征向量，以词节点的<strong>TF-IDF值</strong>作为词节点与句子节点之间的边。</p><p>之后，首先对句子结点值，通过GAT + FNN 进行聚合更新，再用更新后的句子结点对词结点进行更新，最后，对句子进行分类（留或不留），并用Trigram Blocking防止冗余。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwrgywuvjvj30lg0am3yy.jpg" alt="image-20211125162038154" style="zoom:50%;" /><p>结果证明了作者提出的异构图在抽取句子关系时的效果，同时，在CNN/DailyMail等数据集中，表现要优于那些没有使用预训练模型，如BERT的模型。（因为计算资源限制，作者未引入BERT）</p><h3 id="Research-Objective-s"><a href="#Research-Objective-s" class="headerlink" title="Research Objective(s)"></a><strong>Research Objective(s)</strong></h3><p>在抽取式文本摘要领域，为了从一个文档中有效地抽取出值得作为总结的句子，需要对句子之间的关系进行刻画。作者第一个<strong>在基于图的神经网络方法中引入了不同的节点类型来解决文本摘要任务</strong>，并对引入其他类型节点的好处进行了分析。</p><p>we are the first one to introduce different types of nodes into graph-based neural networks for extractive document summarization and perform a comprehensive qualitative analysis to investigate their benefits. </p><h3 id="Background-Problem-Statement"><a href="#Background-Problem-Statement" class="headerlink" title="Background / Problem Statement"></a><strong>Background / Problem Statement</strong></h3><p>文本摘要分为生成式与抽取式，在抽取式文档摘要领域，目标是能够从原始文档中抽取出有重大意义的句子。为了抽取句子，其中一个重要的步骤就是刻画句子间关系，常用的方法有LexRank^[1]^、TextRank^[2]^，基于Approximate Discourse Graph(ADG)^[3]^，基于Rhetorical Structure Theory（RST）^[4]^。但这些方法常常依赖于外部工具，并需要考虑错误传播问题。</p><p>Recently, some works account for discourse inter-sentential relationships when building summarization graphs, such as the Approximate Discourse Graph (ADG) with sentence personalization features (Yasunaga et al., 2017) and Rhetorical Structure Theory (RST) graph (Xu et al., 2019). However, they usually rely on external tools and need to take account of the error propagation problem.</p><p>尽管这些模型取得了不错的成绩，但如何为文本摘要构建一个有效的图结构仍然是一个亟待解决的问题。</p><h3 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a><strong>Method(s)</strong></h3><p>作者引入了更多语义单元作为额外的节点来丰富句子之间的关系。作者选择单词作为语义单元，句子与句子之间没有直接相连的边，这种图结构具有以下优点：</p><ol><li>不同的句子之间可以通过重叠词信息相互作用</li><li>词节点从句子中聚合信息，并进行更新，而其他模型word embedding通常是不变的 </li><li>通过多个消息传递过程，可以充分利用不同粒度的信息。</li><li>作者提出的异构图是可扩展的，例如，可以为多文档摘要任务引入文档结点。</li></ol><p>具体方法：</p><p>给定文档$D = {s_1,s_2,…,s_n}$，我们的目标是预测一系列标注结果$Y = {y_1,y_2,…,y_n}，y_i \in {0,1}$，其中，$y_i = 1$表示该句子$s_i$应该包含在结果中。</p><p>在作者构建的异构图中，基本语义节点作为中继节点，其他单元作为super 结点，super结点与它包含的基本结点相连接，连接的权重为它们关系的重要程度。</p><p>basic semantic nodes (e.g. words, concepts, etc.) as relay nodes and other units of discourse (e.g. phrases, sentences, documents, etc.) as supernodes. Each supernode connects with basic nodes contained in it and takes the importance of the relation as their edge feature. Thus, high-level discourse nodes can establish relationships between each other via basic nodes.</p><img src="/Users/jiayi/Library/Application%20Support/typora-user-images/image-20211123231937172.png" alt="image-20211123231937172" style="zoom:50%;" /><p>如上图所示，作者提出的模型包括三部分：图初始化器、异构图层和句子选择器。</p><p><strong>图初始化器：</strong></p><p>Word Encoder：$X_w \in R^{m \times d_w }$，词嵌入，word embedding，$d_w$是向量维度</p><p>Sentence Encoder：$X_s \in R^{n \times d_s}$，$d_s$为向量维度，其中首先通过CNN获取局部n-gram特征$l_j$，再通过BiLSTM获取句子级别的特征$g_j$，将两者相练，得到最后的向量$X_{sj} = [l_j;g_j]$</p><p>Edge Initializer：使用TF-IDF值，作为边的初始权重。</p><p><strong>异构图层：</strong></p><p>使用GAT^[6]^（graph attention networks）对语义单元结点进行更新。</p><p>$z_{ij} = LeakyReLU(W_a[W_qh_i;W_kh_j;e_{ij}])$</p><p>$\alpha_{ij} = \frac{exp(z_{ij})}{\sum_{l \in N_i}exp(z_{il})}$</p><p>$u_i = \sigma(\sum_{j \in N_i}{\alpha_{ij}W_vh_j})$</p><p>在这里，作者采用<strong>多头self-attention</strong>：</p><p>$u_i = ||<em>{k=1}^K\sigma(\sum</em>{j \in N_i}{\alpha_{ij}W_vh_j})$</p><p>除此之外，增加了<strong>残差连接</strong>解决梯度消失的问题：</p><p>$h’_i = u_i + h_i$</p><p>在每层graph attention layer之后，引入位置前馈层（position-wise FFN），该层由两个线性变换组成，类似Transformer那样。</p><p>之后，如下图所示，句子节点由相连接的词节点通过GAT与FFN进行聚合更新。更新完句子节点后，词节点再由更新后的句子节点进行聚合更新。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq6ltdd3sj30pc0mewhl.jpg" alt="image-20211124133631315" style="zoom:50%;" /><p>最终，出现次数多的单词节点会有更高的degree，表明它可能是该文章的keyword，包含更多keyword的句子理所当然地具备更高的优先级作为输出句子。</p><p><strong>GAT：</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq5eyy671j31240jywg8.jpg" alt="image-20211124125519304" style="zoom:50%;" /><p>单层Graph Attentional Layer输入节点特征向量集：$h = {h_1,h_2,…,h_n},h_i \in R^F$，其中，F为向量维度</p><p>每一层输出为一个新的节点特征向量集合：$h’ = {h’_1,h’_2,…,h’_n},h’_i \in R^{F’}$，其中，F’为新的向量维度</p><p>具体来讲，Graph attentional layer会对输入特征向量进行<strong>self-attention</strong>：$e_{ij} = a(Wh_i, Wh_j)$，其中a是从$R^{F’} \times R^{F’} -&gt; R$的映射，W是被所有$h_i$<strong>共享</strong>的$R^{F’ \times F}$的权值矩阵。这样的操作会将注意力分配到图中的所有节点当中，这样做会丢失结构信息。GAT采用一种masked attention的方式，仅将注意力分配到节点i的邻节点集上。</p><p>$\alpha_{ij} = softmax(e_ij) = \frac{exp(e_{ij})}{\sum_{k \in N_i}exp(e_{ik})}$，其中，$N_i$是结点i的邻近结点集合。</p><p>在<em>Graph Attention Networks</em>中，作者采取了一层前馈网络作为a的实现：</p><p>$\alpha_{ij} = \frac{exp(LeakyReLU(a^T[Wh_i||Wh_j]))}{\sum_{k \in N_i}exp(LeakyReLU(a^T[Wh_i||Wh_k]))} $</p><p>之后，就可以求得$h’<em>i$：$h’<em>i = \sigma(\sum</em>{j \in N_i}{\alpha</em>{ij}Wh_j})$</p><p>此外，为了提高模型的拟合能力，作者引入了多头self-attention，具体实现即同时采用多个$W_k$，之后将结果进行合并或求均值。</p><p>$h_i = {||}<em>{k=1}^K \sigma(\sum</em>{j \in N_i}{\alpha_{ij}W^kh_j})$，这是连接方式，还可以通过均分等方式：</p><p>$h_i = \sigma(\frac{1}{K}\sum_{k=1}^K\sum_{j \in N_i}{\alpha_{ij}W^kh_j})$</p><p><strong>句子选择器：</strong></p><p>对句子节点进行分类，交叉熵损失函数作为训练目标。</p><p>使用<strong>Trigram Blocking</strong>^[5]^，一个MMR方法进行句子去重，对句子进行排序，去掉与前序句子有三叉重合的句子。</p><p><strong>多文档摘要：</strong></p><p>如下图所示，作者通过在异构图中，引入文档节点，通过word node，以<strong>TF-IDF值</strong>作为edge，可以建立起文档与文档之间的层次关系。</p><p>文档结点与句子结点的更新步骤是一样的，与句子结点不同的是，文档结点使用它<strong>包含的句子结点的均值池化值</strong>作为初始值。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwrfezzk1hj30ou0qu42a.jpg" alt="image-20211125152651920" style="zoom:50%;" /><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><p><strong>数据集</strong>：<strong>CNN/DailyMail</strong>、<strong>NYT50</strong>、<strong>Multi-News</strong>（多文档摘要）</p><p><strong>word embedding</strong>：Glove.300d</p><p><strong>optimizer:</strong> Adam</p><p><strong>评价指标：</strong>Rouge-1、Rouge-2、Rouge-L</p><p><strong>Baselines</strong>：</p><p>作者用三种抽取句子间关系的方法进行实验，以此证明<strong>HETERSUMGARPH</strong>在句子关系抽取中的效果更加powerful。</p><ul><li><p>**Ext-BiLSTM **：通过CNN+BiLSTM得到的句子向量直接进行classification</p></li><li><p><strong>Ext-Transformer</strong>：通过Transformer结构对完全连接的句子学习其pairwise交互结构得到encoder</p></li><li><p><strong>HETERSUMGARPH</strong></p></li></ul><p>如下图所示是作者提出的模型在CNN/DailyMail的实验对比结果，可以看出相比于其它的句子关系抽取方法，<strong>作者提出的方法效果更好</strong>。</p><p>并且，作者提出的模型性能要<strong>优于之前所有未以BERT为基础的摘要模型</strong>，并证明了<strong>Trigram blocking</strong>对ROUGE评分具有很好的提升效果，</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwrg6qk4e1j30na0o6n1k.jpg" alt="image-20211125155332812" style="zoom:50%;" /><h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><p>[1] Gu ̈nes Erkan and Dragomir R Radev. 2004. Lexrank: Graph-based lexical centrality as salience in text summarization. <em>Journal of artificial intelligence re- search</em>, 22:457–479.</p><p>[2] Rada Mihalcea and Paul Tarau. 2004. Textrank: Bring- ing order into text. In <em>Proceedings of the 2004 con- ference on empirical methods in natural language processing</em>, pages 404–411.</p><p>[3] Michihiro Yasunaga, Rui Zhang, Kshitijh Meelu, Ayush Pareek, Krishnan Srinivasan, and Dragomir Radev. 2017. Graph-based neural multi-document summarization. <em>arXiv preprint arXiv:1706.06681</em>.</p><p>[4] Jiacheng Xu, Zhe Gan, Yu Cheng, and Jingjing Liu. 2019. Discourse-aware neural extractive model for text summarization. <em>arXiv preprint arXiv:1910.14142</em>.</p><p>[5] Yang Liu and Mirella Lapata. 2019b. Text summariza- tion with pretrained encoders. In <em>Proceedings of the 2019 Conference on Empirical Methods in Nat- ural Language Processing and the 9th International Joint Conference on Natural Language Processing (EMNLP-IJCNLP)</em>, pages 3721–3731, Hong Kong, China. Association for Computational Linguistics.</p><p>[6] Petar Velickovic, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. 2017. Graph attention networks. <em>arXiv preprint arXiv:1710.10903</em>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Heterogeneous-Graph-Neural-Networks-for-Extractive-Document-Summarization&quot;&gt;&lt;a href=&quot;#Heterogeneous-Graph-Neural-Networks-for-Extract</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Attention mechanism</title>
    <link href="http://booleanln.github.io/myblog/2021/11/14/Attention-mechanism/"/>
    <id>http://booleanln.github.io/myblog/2021/11/14/Attention-mechanism/</id>
    <published>2021-11-14T12:50:22.000Z</published>
    <updated>2021-11-14T12:51:53.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Attention-Mechanism"><a href="#Attention-Mechanism" class="headerlink" title="Attention Mechanism"></a>Attention Mechanism</h2><h3 id="最初的attention"><a href="#最初的attention" class="headerlink" title="最初的attention"></a>最初的attention</h3><h3 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self Attention"></a>Self Attention</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Attention-Mechanism&quot;&gt;&lt;a href=&quot;#Attention-Mechanism&quot; class=&quot;headerlink&quot; title=&quot;Attention Mechanism&quot;&gt;&lt;/a&gt;Attention Mechanism&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="自然语言处理" scheme="http://booleanln.github.io/myblog/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++初尝</title>
    <link href="http://booleanln.github.io/myblog/2021/11/10/C-%E5%88%9D%E5%B0%9D/"/>
    <id>http://booleanln.github.io/myblog/2021/11/10/C-%E5%88%9D%E5%B0%9D/</id>
    <published>2021-11-10T07:26:09.000Z</published>
    <updated>2021-11-30T06:50:18.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-初尝"><a href="#C-初尝" class="headerlink" title="C++初尝"></a>C++初尝</h2><blockquote><p>阅读笔记《C++ Primer edition 5th》</p></blockquote><h3 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; include，表示要使用某个库或头文件#include &lt;iostream&gt;#include &quot;Sales_item.h&quot;&#x2F;&#x2F; 标准库命名空间using namespace std;int main()&#123;  &#x2F;&#x2F; 自定义的类以及与其关联的一组操作  Sales_item total;  &#x2F;&#x2F; cin，标准输入，istream对象，输入流，流的意思是随着时间的推移，字符是顺序生成和消耗的。  if (cin &gt;&gt; total) &#123;    Sales_item trans;    while(cin &gt;&gt; trans) &#123;      if(total.isbn() &#x3D;&#x3D; trans.isbn())&#123;        total +&#x3D; trans;      &#125; else &#123;        &#x2F;&#x2F; cout，标准输出，ostream对象，输出流        &#x2F;&#x2F; endl，操纵符的特殊值，效果是结束当前行，将与设备关联的缓冲区内容刷到设备当中        cout &lt;&lt; total &lt;&lt; endl;        total &#x3D; trans;      &#125;    &#125;    cout &lt;&lt; total &lt;&lt; endl;  &#125; else &#123;    &#x2F;&#x2F; 输出错误    cerr &lt;&lt; &quot;There is no data!&quot; &lt;&lt; endl;    return -1;  &#125;  return 0;&#125;&#x2F;&#x2F; 执行 .&#x2F;main &lt;data&#x2F;book_sales &gt;res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwa64eem78j313w06omyz.jpg" alt="image-20211110171045345"></p><p>这个要如何理解？</p><p>首先要了解下<strong>缓冲区</strong>的定义，缓冲区是一块圈定的内存区域，<strong>它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作</strong></p><p><strong>cout</strong>是输出流对象，它会自动关联一块缓冲区，输出的数据一开始是放在缓冲区的，刷新缓冲区操作可以将缓冲区的数据真正地输出到输出设备。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;  cout &lt;&lt; &quot;abcd&quot;; &#x2F;&#x2F; 在缓冲区  cout &lt;&lt; endl; &#x2F;&#x2F; 输出到输出设备  cout &lt;&lt; &quot;def&quot;; &#x2F;&#x2F; 在缓冲区&#125;&#x2F;&#x2F; 程序结束，刷新缓冲区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h3><h4 id="如何选择正确的数据类型？"><a href="#如何选择正确的数据类型？" class="headerlink" title="如何选择正确的数据类型？"></a>如何选择正确的数据类型？</h4><ol><li>当明确数值不可能为负时，选择无符号类型</li><li>使用int执行整数运算，如果超出了int的表示范围，选用long long</li><li>算术表达式中不要使用char或bool。char类型在某些机器上是有符号的，在另一些机器上又是无符号的</li><li>执行浮点运算用double。double精度更高，且与float计算代价相差无几</li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>当一个算术表达式中既有无符号数又有int值时，int值会转换为无符号数。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;  unsigned u &#x3D; 10, u2 &#x3D; 42;  cout &lt;&lt; u2 - u &lt;&lt; endl;  cout &lt;&lt; u - u2 &lt;&lt; endl; &#x2F;&#x2F; 4294967264, 有符号数相减结果为-32，因为是无符号表示，所以实际值为2^32 - 32（补码表示法）  int i &#x3D; 10, i2 &#x3D; 42;  cout &lt;&lt; i2 - i &lt;&lt; endl;  cout &lt;&lt; i - i2 &lt;&lt; endl;  cout &lt;&lt; i - u &lt;&lt; endl;  cout &lt;&lt; u - i &lt;&lt; endl;  int i3 &#x3D; -10;  cout &lt;&lt; i3 - u &lt;&lt; endl; &#x2F;&#x2F; 4294967276  cout &lt;&lt; u + i3 &lt;&lt; endl;  int i4 &#x3D; -20;  cout &lt;&lt; u + i4 &lt;&lt; endl; &#x2F;&#x2F; 4294967286  cout &lt;&lt; i4 + u &lt;&lt; endl; &#x2F;&#x2F; 4294967286&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="花括号初始化（列表初始化）"><a href="#花括号初始化（列表初始化）" class="headerlink" title="花括号初始化（列表初始化）"></a>花括号初始化（列表初始化）</h4><p>列表初始化在C++11后，可以支持包括基本类型在内的所有类型的初始化。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Example &#123;  public:    int a;    int b;    Example() &#x3D; default;    Example(int aIn, int bIn) &#123;      a &#x3D; aIn;      b &#x3D; bIn;    &#125;;&#125;;int main() &#123;  string str(&quot;hello&quot;);  string str2 &#x3D; &quot;world&quot;;  string str3 &#x3D; &#123;&quot;!&quot;&#125;;  cout &lt;&lt; str + str2 + str3 &lt;&lt; endl;  int a &#x3D; 0.1; &#x2F;&#x2F; warning 级别，潜在的类型转换，不会报编译错误  &#x2F;&#x2F; int b &#x3D; &#123;0.1&#125;; &#x2F;&#x2F; error级别，报编译错误    &#x2F;&#x2F; class type也可以用列表初始化  Example example &#x3D; &#123;1,1&#125;;  cout &lt;&lt; example.a &lt;&lt; example.b &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>C++支持<strong>分离式编译</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern int i; &#x2F;&#x2F; 声明变量i，但未进行定义，主要用于文件间代码共享int j; &#x2F;&#x2F; 声明并定义extern int k &#x3D; 3; &#x2F;&#x2F; 定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>C++允许在内层作用域中重新定义外层作用域中已有的名字，将其覆盖掉。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i &#x3D; 100;for (int i &#x3D; 0; i &lt; 10; i++)&#123;  cout&lt;&lt;i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p><em>复合类型指基于其它类型定义的类型</em></p><h5 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h5><p>指针的定义：</p><p>Pointers store address of variables or a memory location. </p><p>指针存储变量的地址或指向一块内存地址。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int var &#x3D; 10;int *p &#x3D; &amp;var;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F; 10cout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F; 0x7ffa0...*p &#x3D; 20;cout &lt;&lt; var &lt;&lt; endl; &#x2F;&#x2F; 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwmvlekx59j30xo0gwmya.jpg" alt="image-20211121165847840"></p><p>指针对象支持自增（++）与自减（–）操作，增加的长度为指针类型的长度，如int指针增加4</p><p><img src="/Users/jiayi/Library/Application%20Support/typora-user-images/image-20211121170353544.png" alt="image-20211121170353544"></p><p><strong>引用</strong>的定义：</p><p>When a variable is declared as a reference, it becomes an alternative name for an existing variable.</p><p>引用其实就是给已存在的对象起了一个别名，类似于“阿里的花名”😁，给风清扬一拳，也表示给了马云一拳。</p><p><strong>常用场景</strong>：</p><ol><li><p><strong>Modify the passed parameters in a function</strong>，修改函数传参</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1, b &#x3D; 2;swap(a,b);cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;void swap(int &amp;a, int &amp;b)&#123;  int tmp &#x3D; a;  a &#x3D; b;  b &#x3D; a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>Avoiding a</strong> <strong>copy of large structures</strong>，避免大对象的copy浪费空间</p><p>在函数传递时，通过引用类型，避免大对象的copy</p></li><li><p><strong>In For Each Loops to modify all objects</strong></p><p>在foreach中，修改对象</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; vect&#123; 10, 20, 30, 40 &#125;; for(int &amp;x:vect) &#123;  x &#x3D; x + 5;&#125;for(int x:vect)&#123;  cout &lt;&lt; x; &#x2F;&#x2F; &#123;15, 25, 35, 45&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>For Each Loop to avoid the</strong> <strong>copy of objects</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;string&gt; strs&#123;&quot;aaabbb&quot;, &quot;bbbccc&quot;, &quot;cccddd&quot;&#125;;for(string &amp;str: strs)&#123;  cout &lt;&lt; str; &#x2F;&#x2F; 避免进行值copy&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int k, &amp;rk &#x3D; k; &#x2F;&#x2F; &amp; 表示rk是一个reference，引用型变量，rk可以理解为k的别名 k &#x3D; 5; rk &#x3D; 10; &#x2F;&#x2F;  对rk进行操作，会影响到k cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; rk &lt;&lt; endl; int i &#x3D; 10; int *p &#x3D; nullptr; &#x2F;&#x2F; 空指针，*表示p为指针变量 p &#x3D; &amp;i; &#x2F;&#x2F; 给指针变量赋值，&amp;为取地址符号 cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F; *为解引用符，对指针解引用可以得到所指的对象，因此可以获得i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Pointer-vs-Reference"><a href="#Pointer-vs-Reference" class="headerlink" title="Pointer vs Reference"></a>Pointer vs Reference</h5><ol><li>引用初始化<strong>必须进行赋值</strong>，且<strong>不可变</strong>，指针则本身是一个对象，允许对它进行赋值和拷贝，<strong>可以先后指向不同的对象</strong>，定义时也<strong>不须赋初值</strong></li><li>在调用栈上，<strong>指针有自己的地址和内存空间</strong>，而引用与原变量共享同一个地址。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int test  &#x3D; 10, *pt &#x3D; &amp;test, &amp;rt &#x3D; test;cout &lt;&lt; &amp;test &lt;&lt; &quot; &quot; &lt;&lt; &amp;pt &lt;&lt; &quot; &quot; &lt;&lt; &amp;rt &lt;&lt; &quot; &quot; &lt;&lt; pt &lt;&lt; endl;&#x2F;&#x2F; 0x7ffeeca40454 0x7ffeeca40448 0x7ffeeca40454 0x7ffeeca40454<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>指针可以有多级，而引用只提供一级</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int **p; &#x2F;&#x2F; validint &amp;&amp;q;&#x2F;&#x2F; error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="C-内存布局"><a href="#C-内存布局" class="headerlink" title="C++内存布局"></a>C++内存布局</h3><ol><li><p>进程与线程</p><p>进程是操作系统分配资源的最小单位，在操作系统中，进程的创建等管理与PCB(Process Control Block)这个结构息息相关，<strong>PCB是进程存在的唯一标志</strong>。PCB当中包含了管理进程的信息：</p><ul><li>进程标识符</li><li>进程调度信息</li><li>进程控制信息</li></ul><p>例如<code>task_struct</code>是linux对PCB的实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span><span class="token comment">/* these are hardcoded - don't touch */</span>    <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token comment">/* -1 unrunnable, 0 runnable, >0 stopped */</span>    <span class="token keyword">long</span> counter<span class="token punctuation">;</span>    <span class="token keyword">long</span> priority<span class="token punctuation">;</span>    <span class="token keyword">long</span> signal<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sigaction<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> blocked<span class="token punctuation">;</span>    <span class="token comment">/* bitmap of masked signals */</span><span class="token comment">/* various fields */</span>    <span class="token keyword">int</span> exit_code<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span>end_code<span class="token punctuation">,</span>end_data<span class="token punctuation">,</span>brk<span class="token punctuation">,</span>start_stack<span class="token punctuation">;</span>    <span class="token keyword">long</span> pid<span class="token punctuation">,</span>pgrp<span class="token punctuation">,</span>session<span class="token punctuation">,</span>leader<span class="token punctuation">;</span>    <span class="token keyword">int</span>    groups<span class="token punctuation">[</span>NGROUPS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/*     * pointers to parent process, youngest child, younger sibling,     * older sibling, respectively.  (p->father can be replaced with     * p->p_pptr->pid)     *parent     */ |         \     * younger sibling  &lt;- me -> older sibling     *.            |     *               youngest child     */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>    <span class="token operator">*</span>p_pptr<span class="token punctuation">,</span> <span class="token operator">*</span>p_cptr<span class="token punctuation">,</span> <span class="token operator">*</span>p_ysptr<span class="token punctuation">,</span> <span class="token operator">*</span>p_osptr<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> uid<span class="token punctuation">,</span>euid<span class="token punctuation">,</span>suid<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> gid<span class="token punctuation">,</span>egid<span class="token punctuation">,</span>sgid<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span>alarm<span class="token punctuation">;</span>    <span class="token keyword">long</span> utime<span class="token punctuation">,</span>stime<span class="token punctuation">,</span>cutime<span class="token punctuation">,</span>cstime<span class="token punctuation">,</span>start_time<span class="token punctuation">;</span>  <span class="token comment">/* resource limit */</span>    <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> rlim<span class="token punctuation">[</span>RLIM_NLIMITS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token comment">/* per process flags, defined below */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> used_math<span class="token punctuation">;</span><span class="token comment">/* file system info */</span>    <span class="token keyword">int</span> tty<span class="token punctuation">;</span>        <span class="token comment">/* -1 if no tty, so it must be signed */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> umask<span class="token punctuation">;</span>  <span class="token comment">/* m_inode 内存inode*/</span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> pwd<span class="token punctuation">;</span> <span class="token comment">// 当前目录节点</span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> root<span class="token punctuation">;</span> <span class="token comment">// 根目录节点</span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> executable<span class="token punctuation">;</span> <span class="token comment">// </span>    <span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> library<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> close_on_exec<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> filp<span class="token punctuation">[</span>NR_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span>    <span class="token keyword">struct</span> <span class="token class-name">desc_struct</span> ldt<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* tss for this task */</span>    <span class="token keyword">struct</span> <span class="token class-name">tss_struct</span> tss<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程是CPU调度的最小单位，线程之间共享进程的存储区域、CPU资源，同一时刻，只有一个线程任务会被执行。在Linux中，线程与进程一样都是<code>task_struct</code>，在windows中，存在TCB(Thread Control Block)，是线程的控制实体。</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-初尝&quot;&gt;&lt;a href=&quot;#C-初尝&quot; class=&quot;headerlink&quot; title=&quot;C++初尝&quot;&gt;&lt;/a&gt;C++初尝&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;阅读笔记《C++ Primer edition 5th》&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
    <category term="C++" scheme="http://booleanln.github.io/myblog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Multi-document Summarization via Deep Learning Techniques: A Survey</title>
    <link href="http://booleanln.github.io/myblog/2021/11/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Multi-document-Summarization-via-Deep-Learning-Techniques-A-Survey/"/>
    <id>http://booleanln.github.io/myblog/2021/11/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Multi-document-Summarization-via-Deep-Learning-Techniques-A-Survey/</id>
    <published>2021-11-08T09:07:02.000Z</published>
    <updated>2021-11-15T12:28:28.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Multi-document-Summarization-via-Deep-Learning-Techniques-A-Survey"><a href="#Multi-document-Summarization-via-Deep-Learning-Techniques-A-Survey" class="headerlink" title="Multi-document Summarization via Deep Learning Techniques: A Survey"></a>Multi-document Summarization via Deep Learning Techniques: A Survey</h2><p><em>基于深度学习的多文档摘要模型综述</em></p><p><strong>Computation and Language. 2020. <a href="https://arxiv.org/search/cs?searchtype=author&query=Ma,+C">Congbo Ma</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Zhang,+W+E">Wei Emma Zhang</a></strong></p><pre class="line-numbers language-none"><code class="language-none">@misc&#123;ma2020multidocument,      title&#x3D;&#123;Multi-document Summarization via Deep Learning Techniques: A Survey&#125;,       author&#x3D;&#123;Congbo Ma and Wei Emma Zhang and Mingyu Guo and Hu Wang and Quan Z. Sheng&#125;,      year&#x3D;&#123;2020&#125;,      eprint&#x3D;&#123;2011.04843&#125;,      archivePrefix&#x3D;&#123;arXiv&#125;,      primaryClass&#x3D;&#123;cs.CL&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><h3 id="Research-Objective-s"><a href="#Research-Objective-s" class="headerlink" title="Research Objective(s)"></a><strong>Research Objective(s)</strong></h3><p>作者的研究目标是什么？</p><h3 id="Background-Problem-Statement"><a href="#Background-Problem-Statement" class="headerlink" title="Background / Problem Statement"></a><strong>Background / Problem Statement</strong></h3><p>研究的背景以及问题陈述：作者需要解决的问题是什么？</p><h3 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a><strong>Method(s)</strong></h3><p>多文档摘要的目标是从一批文档集合D中生成一个简洁且信息丰富的摘要Sum。文档集合D是主题相关的一系列文本。</p><p>The aim of multi- document summarization is to generate a concise and informative summary 𝑆𝑢𝑚 from a collection ofdocuments𝐷.𝐷denotesaclusteroftopic-relateddocuments{𝑑𝑖 |𝑖∈[1,𝑁]},where𝑁isthe number of documents. Each document 𝑑𝑖 consists of 𝑀 sentences 􏰈𝑠𝑖,𝑗 | 𝑗 ∈ [1, 𝑀]􏰉. 𝑠𝑖,𝑗 refers to the 𝑗-th sentence in the 𝑖-th document. </p><p>作者对多文档摘要的流程进行了总结与梳理，通常包括1⃣️选择一个合适的文档连接方法2⃣️对文档进行预处理3⃣️通过深度学习模型获取语义丰富的表达4⃣️融合各种类型的表达，5⃣️句子选择或摘要生成</p><p>The first step is to select an appropriate concatenation approach for input documents. The second step is pre-processing these documents, such as segmenting sentences, tokenizing non-alphabetic characters and removing punctuations [118]. Then, an appropriate deep learning based model is chosen to generate semantic rich representation for downstream tasks. The next step is to fuse these various types of representation for later sentence selection or summary generation. Finally, through these five steps, multiple documents are transformed into concise and informative summaries.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw7z2428ezj312u0aojsn.jpg" alt="image-20211108193513722"></p><h4 id="input-document-types-输入文档类型"><a href="#input-document-types-输入文档类型" class="headerlink" title="input document types 输入文档类型"></a>input document types 输入文档类型</h4><ul><li><p>多篇短文档 Many short documents.</p><p>每篇文档长度相对较短，但数量很大，如产品评论生成。</p></li><li><p>少量长文档 Few long documents.</p><p>每篇文档长度相对较长，但数量较少，如新闻摘要生成。</p></li><li><p>混合文档类型 Hybrid documents. </p><p>一篇或多篇长文档同时伴随着若干篇短文档，如新闻稿+新闻短评，论文+简短的引用。</p></li></ul><h4 id="Concatenation-Methods-连接方法"><a href="#Concatenation-Methods-连接方法" class="headerlink" title="Concatenation Methods 连接方法"></a>Concatenation Methods 连接方法</h4><ol><li><p>Flat Concatenation 平滑连接</p><p>将所有输入文档囊括在一个输入当中，并当作一个整体的sequence进行处理，简单但powerful。</p><p> All input documents are spanned and are processed as a flat sequence.</p></li><li><p>Hierarchical Concatenation 分层连接</p><p>借助分层连接，有助于模型获得语义丰富的表示，从而提高模型的有效性。当前的分层连接方法，包含两种方案：</p><ul><li><p>文档级别：分别得到文档的摘要表示，这些表示在后续过程中进行融合。</p><p>For the document-level concatenation methods, a condense model [3] is proposed to learn document-level representation separately in a cluster and these representation are fused in the subsequent processes.</p></li><li><p>单词/句子级别：包含聚类与关系图方法</p><p><strong>聚类方法：</strong>首先对输入对文档进行句子级聚类，然后从不同的聚类中选择句子，保证最多从一个聚类中选择出一个句子，从而减少冗余信息，并提高信息的覆盖率。</p><p>First allowing the model group related sentences. Then, the model selects sentences from diverse clusters, and at most one sentence will be selected from a cluster. By doing so, it will decrease redundancy and increase the information coverage for the generated summaries.</p><p><strong>关系图方法：</strong>构造句子关系图来表示文档之间的层次关系，常用的构造方法有余弦相似图、近似语篇图以及个性化语篇图。还有一种异构图模型利用单词构造句子与句子、句子与文档之间的关系图。</p><p>Cosine similarity graph, approximate discourse graph, and personalized discourse graph are the most commonly used methods recently for building sentence graph structures. The heterogeneous graph model leverages words as intermediate nodes to construct a document-document, sentence-sentence and sentence-document hierarchical structure.</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw7wtp5l44j310w0u00x5.jpg" alt="image-20211108181754273"></p></li></ol><h4 id="Summarization-Construction-Types-摘要构造方法"><a href="#Summarization-Construction-Types-摘要构造方法" class="headerlink" title="Summarization Construction Types 摘要构造方法"></a>Summarization Construction Types 摘要构造方法</h4><ol><li>abstractive summarization 生成式摘要</li><li>extractive summarization 抽取式摘要</li><li>hybrid summarization 混合方法摘要</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw7yphbejuj313w0fe0wb.jpg" alt="image-20211108192305082"></p><p>作者提出了一种概括模型结构的新方法，将模型结构分为了以下类型：</p><p>其中，绿色虚线box可以由其它网络模型灵活代替，蓝色实线box则表明通过神经网络或启发式设计方法进行的嵌入操作，可以是句子/文档等类型的表达。</p><p> In this figure, deep neural models are boxed in green dotted line, which can be flexibly substituted by other backbone networks. The blue solid line boxes indicate the neural embeddings processed by neural networks or heuristic-designed approaches. It can be sentence/document representation or other types of representation. </p><ul><li><p>Naive Networks</p><p>朴素网络，DNN model作用是一个特征提取器，得到的representation交由下游做句子选择或摘要生成。</p></li><li><p>Ensemble Networks.</p><p>集成网络，输入docuemnts至多个模型，之后各模型得到的表达会进行融合来提高模型整体的表达能力。主流融合方法有投票或均值。</p><p>Ensemble networks feed input documents to multiple paths with different network structures or operations. Later on, these representations are fused to enhance model expression capability. The majority vote or average can be used to determine the final solution.</p></li><li><p>Auxiliary Task Networks</p></li><li><p>Reconstruction Networks</p></li><li><p>Fusion Networks. Fusion networks </p></li><li><p>Graph Neural Networks</p></li><li><p>Hierarchical Networks</p><p>文档集连接后输入第一层DNN后，获得其表层特征，之后将该第一层输出作为第二层DNN的输入，生成深层次表征，分层模型可以更有效地提取抽象层次和语义特征。</p><p>The Hierarchical networks empower the model with the ability to capture abstract-level and semantic-level features more efficiently.</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw7z7p99rdj310p0u0aes.jpg" alt="image-20211108194035375"></p><h4 id="RNN-based-Models"><a href="#RNN-based-Models" class="headerlink" title="RNN based Models"></a>RNN based Models</h4><h4 id="CNN-based-Models"><a href="#CNN-based-Models" class="headerlink" title="CNN based Models"></a>CNN based Models</h4><h4 id="GNN-based-Models"><a href="#GNN-based-Models" class="headerlink" title="GNN based Models"></a>GNN based Models</h4><p>自然语言数据通常由关系密切的词汇和短语组成，相比于序列的表示方法，图结构能够更好地进行表示。</p><p>Natural language data consist of vocabularies and phrases with strong relations and they can be better represented with graphs rather than in sequential orders</p><ol><li><p>基于GCN的方法^[1]^ ：构建句子关系图，送入GCN获得句子相关特征。</p><p>This model first builds a sentence-based graph and then feeds the pre-processed data into a GCN [60] to capture the sentence-wise related features.</p><p><strong>构造图的方法：</strong>每个句子视作一个结点，句子间的关系为边，关系有余弦相似度、近似语篇、个性化语篇等。</p><p>Defined by the model, each sentence is regarded as a node and the relation between each pair of sentences is defined as an edge. Inside each document cluster, the sentence relation graph can be generated through cosine similarity graph [32], approximate discourse graph [23] and the proposed personalized discourse graph. </p><p>句子关系图以及RNN抽取出embedding，都送入图卷积神经网络来得到句子最终的表达。最后将输出送入<strong>文档GRU</strong>完成集群嵌入，完全聚合句子之间的特征。</p><p>Both of the sentence relation graph and sentence embeddings extracted by a sentence-level RNN are fed into graph convolution networks to produce the final sentence representation. With the help of a document-level GRU, the model generates cluster embeddings to fully aggregate features between sentences.</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw95ox3f02j31440f4q4w.jpg" alt="image-20211109201016184"></p></li><li><p>基于异构图的方法^[3]^ ：上面的方法只利用了句子级的关系，没有充分考虑单词、句子以及文章之间的关系。</p><p>The existing graph neural networks based models are mainly focused on the relationship between sentences and do not fully consider the relations among words, sentences and documents</p><p> HeterDoc-Sum Graph^[3]^是一种基于异构图注意力网络，它包含了单词节点、句子节点以及文章节点，句子节点和文章节点通过共现单词关系相连接</p><p>Sentence nodes and document nodes are connected according to the contained word nodes. </p><p>TF-IDF值作为单词-句子以及单词-文章的权重</p><p>三种关系图送入图注意力网络^[2]^中进行权重更新，每次更新时，对单词句子和单词文档进行双向更新，以更好地聚合跨层语义知识。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaau91zzlj30pk0qkjv6.jpg" alt="image-20211110195359995"></p></li></ol><h4 id="PGNet-based-Models"><a href="#PGNet-based-Models" class="headerlink" title="PGNet based Models"></a>PGNet based Models</h4><p>Pointer-generator 网络被提出来解决摘要领域的事实错误以及高冗余性问题。</p><p>Pointer-generator networks is proposed to overcome the problems of factual errors and high redundancy in the summarization task. </p><p>这类网络架构受到了pointer network、copynet、forced-attention sentence compression 以及 coverage mechanism的启发。对这些概念进行介绍：</p><p><strong>pointer network</strong></p><p><strong>copynet</strong></p><p><strong>converage mechanism</strong></p><p><strong>MMR（Maximal Marginal Relevance）</strong><br>$$<br>MMR = ArgMAX_{Di\ in \ 未选中集合}[\lambda Sim_1(D_i,Q) - (1-\lambda)max_{Dj \ in \ 已选中集合}Sim_2(Di,D_j))]<br>$$<br><em>其中Q为用户，前半部分在摘要领域是对句子的打分。</em></p><p>该方法目的在于减少排序结果的冗余，保证结果的多样性，常用于推荐领域。</p><p>More accurately, the MMR scores are multiplied to the original attention weights. MMR method is designed to select a set of salience sentences from source documents by considering both importance and redundancy indexes</p><h4 id="Encoder-decoder-based-Models"><a href="#Encoder-decoder-based-Models" class="headerlink" title="Encoder-decoder based Models"></a>Encoder-decoder based Models</h4><p><strong>Encoder：</strong>对原文档进行编码表示，编码包含了压缩语义和句法信息</p><p><strong>Decoder：</strong>对encoder的编码结果进行处理，生成目标摘要</p><p>For multi-document summarization, the encoder embeds source documents into the hidden representations, i.e., word representation, sentence representation and document representation. Then, the representation containing compressed semantic and syntactic information is passed to the decoder to generate the target summaries. </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwackd5wj8j312g0ckabf.jpg" alt="image-20211110205341614"></p><h4 id="Variational-Auto-Encoder-based-Models"><a href="#Variational-Auto-Encoder-based-Models" class="headerlink" title="Variational Auto-Encoder based Models"></a>Variational Auto-Encoder based Models</h4><p>变分自编码器：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwacpjz9ulj315s09wgn2.jpg" alt="image-20211110205840492"></p><h4 id="Transformer-based-Models"><a href="#Transformer-based-Models" class="headerlink" title="Transformer based Models"></a>Transformer based Models</h4><h4 id="Deep-Hybrid-Models"><a href="#Deep-Hybrid-Models" class="headerlink" title="Deep Hybrid Models"></a>Deep Hybrid Models</h4><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><p>作者如何评估自己的方法？实验的setup是什么样的？感兴趣实验数据和结果有哪些？有没有问题或者可以借鉴的地方？</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h3><p>作者给出了哪些结论？哪些是strong conclusions, 哪些又是weak的conclusions（即作者并没有通过实验提供evidence，只在discussion中提到；或实验的数据并没有给出充分的evidence）?</p><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><p>(optional) 不在以上列表中，但需要特别记录的笔记。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><p>[1] Michihiro Yasunaga, Rui Zhang, Kshitijh Meelu, Ayush Pareek, Krishnan Srinivasan, and Dragomir R. Radev. 2017. Graph-based Neural Multi-Document Summarization. In Proceedings of the 21st Conference on Computational Natural Language Learning (CoNLL 2017).</p><p>[2] Petar Veličković, Guillem Cucurull, Arantxa Casanova, Adriana Romero, Pietro Lio, and Yoshua Bengio. 2017. Graph Attention Networks. arXiv preprint arXiv:1710.10903.</p><p>[3] Danqing Wang, Pengfei Liu, Yining Zheng, Xipeng Qiu, and Xuanjing Huang. 2020. Heterogeneous Graph Neural Networks for Extractive Document Summarization. arXiv preprint arXiv:2004.12393.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Multi-document-Summarization-via-Deep-Learning-Techniques-A-Survey&quot;&gt;&lt;a href=&quot;#Multi-document-Summarization-via-Deep-Learning-Techniq</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-TED: A Pretrained Unsupervised Summarization Model with Theme Modeling and Denoising</title>
    <link href="http://booleanln.github.io/myblog/2021/11/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-TED-A-Pretrained-Unsupervised-Summarization-Model-with-Theme-Modeling-and-Denoising/"/>
    <id>http://booleanln.github.io/myblog/2021/11/06/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-TED-A-Pretrained-Unsupervised-Summarization-Model-with-Theme-Modeling-and-Denoising/</id>
    <published>2021-11-06T09:01:59.000Z</published>
    <updated>2021-12-06T12:02:01.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TED-A-Pretrained-Unsupervised-Summarization-Model-with-Theme-Modeling-and-Denoising"><a href="#TED-A-Pretrained-Unsupervised-Summarization-Model-with-Theme-Modeling-and-Denoising" class="headerlink" title="TED: A Pretrained Unsupervised Summarization Model with Theme Modeling and Denoising"></a>TED: A Pretrained Unsupervised Summarization Model with Theme Modeling and Denoising</h2><p><em>一种基于主题建模和去噪的无监督预训练摘要生成模型</em></p><p><strong>{2020.EMNLP. Ziyi Yang. Chenguang Zhu}</strong></p><pre class="line-numbers language-none"><code class="language-none">@misc&#123;yang2020ted,      title&#x3D;&#123;TED: A Pretrained Unsupervised Summarization Model with Theme Modeling and Denoising&#125;,       author&#x3D;&#123;Ziyi Yang and Chenguang Zhu and Robert Gmyr and Michael Zeng and Xuedong Huang and Eric Darve&#125;,      year&#x3D;&#123;2020&#125;,      eprint&#x3D;&#123;2001.00725&#125;,      archivePrefix&#x3D;&#123;arXiv&#125;,      primaryClass&#x3D;&#123;cs.CL&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><h3 id="Research-Objective-s"><a href="#Research-Objective-s" class="headerlink" title="Research Objective(s)"></a><strong>Research Objective(s)</strong></h3><ol><li>以往的模型基于RNN实现，而新提出的transformer性能更好</li><li>以往的摘要模型忽略了在大规模未标注语料的预训练</li></ol><p>基于上述问题，作者提出基于Transformer的无监督生成模型。模型基于以下思路：</p><ul><li>首先在未标注的大规模语料上进行训练</li><li>对TED模型基于主题模型与去噪自编码器提高生成摘要的质量</li></ul><h3 id="Background-Problem-Statement"><a href="#Background-Problem-Statement" class="headerlink" title="Background / Problem Statement"></a><strong>Background / Problem Statement</strong></h3><p>作者提出一种基于Transformer的无监督生成模型，贡献体现在：</p><ol><li><p>TED预训练：</p><p><strong>新闻文体采用倒金字塔结构，可用新闻的开头若干句，作为摘要内容</strong>。基于此假设，作者对模型在大规模未标注的语料上进行无监督预训练</p></li><li><p>TED finetune：</p><p>在具体的数据集上进行finetune，作者基于<strong>主题模型损失</strong>以及<strong>去噪自编码器</strong>进行finetune。</p><p>其中，主题模型loss目标是生成的文本与原始文本<strong>语义上更相近</strong>，而去噪自编码器目标是帮助模型从原始文本中，<strong>抽取主要信息</strong></p></li><li><p>为了解决生成模型常见的OOV问题，作者采用了<strong>SentencePiece tokenization</strong>^[1]^</p></li></ol><h3 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a><strong>Method(s)</strong></h3><ol><li>基于Transformer的Encoder-Decoder结构</li></ol><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4d4pyey1j31fo0hodib.jpg" alt="image-20211206200009560" style="zoom:50%;" /><ol start="2"><li>无监督预训练</li><li>主题模型</li><li>去噪自编码器</li></ol><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h3><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><p>[1] Taku Kudo and John Richardson. 2018. Sentencepiece: A simple and language independent subword tok- enizer and detokenizer for neural text processing. <em>arXiv preprint arXiv:1808.06226</em>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TED-A-Pretrained-Unsupervised-Summarization-Model-with-Theme-Modeling-and-Denoising&quot;&gt;&lt;a href=&quot;#TED-A-Pretrained-Unsupervised-Summari</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://booleanln.github.io/myblog/2021/11/04/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88/"/>
    <id>http://booleanln.github.io/myblog/2021/11/04/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E6%A8%A1%E7%89%88/</id>
    <published>2021-11-04T07:17:33.945Z</published>
    <updated>2021-11-08T08:35:12.895Z</updated>
    
    <content type="html"><![CDATA[<p><strong># {Title}（文章标题）</strong></p><p><strong>{Year}, {Authors}, {Journal Name}</strong></p><p><strong>{引用格式}</strong></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><p>写完笔记之后最后填，概述文章的内容，以后查阅笔记的时候先看这一段。注：写文章summary切记需要通过自己的思考，用自己的语言描述。忌讳直接Ctrl + c原文。</p><h3 id="Research-Objective-s"><a href="#Research-Objective-s" class="headerlink" title="Research Objective(s)"></a><strong>Research Objective(s)</strong></h3><p>作者的研究目标是什么？</p><h3 id="Background-Problem-Statement"><a href="#Background-Problem-Statement" class="headerlink" title="Background / Problem Statement"></a><strong>Background / Problem Statement</strong></h3><p>研究的背景以及问题陈述：作者需要解决的问题是什么？</p><h3 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a><strong>Method(s)</strong></h3><p>作者解决问题的方法/算法是什么？是否基于前人的方法？基于了哪些？</p><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a><strong>Evaluation</strong></h3><p>作者如何评估自己的方法？实验的setup是什么样的？感兴趣实验数据和结果有哪些？有没有问题或者可以借鉴的地方？</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h3><p>作者给出了哪些结论？哪些是strong conclusions, 哪些又是weak的conclusions（即作者并没有通过实验提供evidence，只在discussion中提到；或实验的数据并没有给出充分的evidence）?</p><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a><strong>Notes</strong></h3><p>(optional) 不在以上列表中，但需要特别记录的笔记。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h3><p>(optional) 列出相关性高的文献，以便之后可以继续track下去。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw355lq4fuj30u01jvjz7.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;# {Title}（文章标题）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{Year}, {Authors}, {Journal Name}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{引用格式}&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Sum</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池源码探究</title>
    <link href="http://booleanln.github.io/myblog/2021/10/23/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/"/>
    <id>http://booleanln.github.io/myblog/2021/10/23/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</id>
    <published>2021-10-23T05:24:48.000Z</published>
    <updated>2021-12-06T09:49:04.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池源码"><a href="#线程池源码" class="headerlink" title="线程池源码"></a>线程池源码</h3><h4 id="为什么需要线程池？"><a href="#为什么需要线程池？" class="headerlink" title="为什么需要线程池？"></a>为什么需要线程池？</h4><ol><li>提高线程利用率</li><li>减少因为创建、销毁线程所带来的性能损耗</li><li>提高吞吐量</li></ol><h4 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并指定线程池的<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>keepAliveTime</code>、<code>unit</code>、<code>workQueue</code>、<code>threadFactory</code>、<code>handler</code></p><h4 id="线程池执行逻辑？"><a href="#线程池执行逻辑？" class="headerlink" title="线程池执行逻辑？"></a>线程池执行逻辑？</h4><p>首先介绍下线程池参数概念：</p><p>corePoolSize：核心线程数，线程池基本大小</p><p>maximumPoolSize：最大线程数，同一时刻内线程池中线程的数量最大阈值。</p><p>keepAliveTime：工作线程最大空闲时间，超过该空闲时间，工作线程将会被回收</p><p>unit：keepAliveTime的时间单位</p><p>wordQueue：任务队列，用来存放任务。</p><p>threadFactory：线程池创建工厂类（默认为<code>DefaultThreadFactory</code>）</p><p>handler：拒绝策略：</p><ul><li>AbortPolicy：拒绝，抛出异常（<strong>默认策略</strong>）</li><li>CallerRunsPolicy：提交任务的线程自己处理</li><li>DiscardPolicy：不处理，直接丢弃</li><li>DiscardOldestPolicy：丢弃排在最前面的任务，并执行当前任务</li></ul><h4 id="其它线程池相关术语"><a href="#其它线程池相关术语" class="headerlink" title="其它线程池相关术语"></a>其它线程池相关术语</h4><ol><li><p>ThreadFactory</p><p>线程工厂，用于线程池创建线程</p><ul><li><p>ThreadGroup：线程组，一组方便管理的线程集合，整体呈树形关系，如下图（来源于网络）所示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx467chs4fj30ns0mmaar.jpg" alt="image-20211206160029819"></p></li><li><p>ThreadName</p><p>线程名称，用于创建线程时，指定线程名称</p></li><li><p>Daemon</p><p>是否为守护线程</p></li><li><p>Priority</p><p>线程优先级</p></li></ul><p>以比较常用的<code>DefaultThreadFactory</code>为例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 并发控制量，反映当前pool中创建的线程名称数量</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> poolNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ThreadGroup</span> group<span class="token punctuation">;</span>  <span class="token comment">// 并发控制量，反映当前pool中创建的线程数量</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> namePrefix<span class="token punctuation">;</span>        <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">// 系统安全管理器，保证操作的安全性</span>            <span class="token class-name">SecurityManager</span> s <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>                                  <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span>                          poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                         <span class="token string">"-thread-"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>   <span class="token comment">// 重写的方法</span>        <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>                                  namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 创建非守护线程  </span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 创建线程优先级为NORM_PRIORITY</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span>                t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="线程池实现源码"><a href="#线程池实现源码" class="headerlink" title="线程池实现源码"></a>线程池实现源码</h4><ol><li><p>Worker工作线程类</p><p>Worker类继承了AQS，目的是简化获取和释放任务执行时所需锁的操作。</p><p>加锁的原因：</p><ol><li>防止在运行过程中被中断</li></ol></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>        <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>        <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 线程，默认为NULL，factory创建失败也为NULL</span>  <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>  <span class="token comment">// 初始化任务</span>  <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>  <span class="token comment">// 任务计数器</span>  <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 禁止中断</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// </span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 重写tryAcquire方法，CAS获取锁</span>  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token comment">// 重写AQS-tryRelease方法</span>  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 首先调用tryAcquire方法获取🔒，获取不到，则加入等待队列</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 调用tryAcquire方法获取🔒，获取不到，返回false</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 调用tryRelease，并唤醒后续线程</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// 中断当前线程</span>  <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>    <span class="token comment">// state为-1时，不可中断</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行worker线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// If pool is stopping, ensure thread is interrupted;</span>            <span class="token comment">// if not, ensure thread is not interrupted.  This</span>            <span class="token comment">// requires a recheck in second case to deal with</span>            <span class="token comment">// shutdownNow race while clearing interrupt</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>执行方法<code>execute</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1. 小于核心线程数，无论当前其它核心线程是否空闲，都创建新线程</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 2. 大于核心线程数，则添加至阻塞队列</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.1 添加成功，检测线程池状态</span>    <span class="token comment">// 2.1.1 线程池关闭，则移走任务，走reject策略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2.1.2 当一个worker都没有时，则添加worker</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 3. 队列满时，创建新线程执行，如果超出maximumPoolSize，则reject策略</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvp7x6wdp4j61qi0s8whx02.jpg" alt="image-20211023141607308"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;线程池源码&quot;&gt;&lt;a href=&quot;#线程池源码&quot; class=&quot;headerlink&quot; title=&quot;线程池源码&quot;&gt;&lt;/a&gt;线程池源码&lt;/h3&gt;&lt;h4 id=&quot;为什么需要线程池？&quot;&gt;&lt;a href=&quot;#为什么需要线程池？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="面试" scheme="http://booleanln.github.io/myblog/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="java" scheme="http://booleanln.github.io/myblog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Sentence Centrality Revisited for Unsupervised Summarization</title>
    <link href="http://booleanln.github.io/myblog/2021/10/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Sentence-Centrality-Revisited-for-Unsupervised-Summarization/"/>
    <id>http://booleanln.github.io/myblog/2021/10/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Sentence-Centrality-Revisited-for-Unsupervised-Summarization/</id>
    <published>2021-10-19T08:11:15.000Z</published>
    <updated>2021-11-06T08:59:54.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sentence-Centrality-Revisited-for-Unsupervised-Summarization（基于再访问句子中心性的无监督文本摘要生成）"><a href="#Sentence-Centrality-Revisited-for-Unsupervised-Summarization（基于再访问句子中心性的无监督文本摘要生成）" class="headerlink" title="Sentence Centrality Revisited for Unsupervised Summarization（基于再访问句子中心性的无监督文本摘要生成）"></a>Sentence Centrality Revisited for Unsupervised Summarization（基于再访问句子中心性的无监督文本摘要生成）</h2><p><em>2019.6.8 Hao Zheng. Mirella Lapata. ACL 2019</em></p><pre class="line-numbers language-none"><code class="language-none">@misc&#123;zheng2019sentence,      title&#x3D;&#123;Sentence Centrality Revisited for Unsupervised Summarization&#125;,       author&#x3D;&#123;Hao Zheng and Mirella Lapata&#125;,      year&#x3D;&#123;2019&#125;,      eprint&#x3D;&#123;1906.03508&#125;,      archivePrefix&#x3D;&#123;arXiv&#125;,      primaryClass&#x3D;&#123;cs.CL&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[code地址](<a href="https://github.com/">https://github.com/</a> mswellhao/PacSum)</p><h3 id="0-Summary"><a href="#0-Summary" class="headerlink" title="0. Summary"></a>0. Summary</h3><p>作者在本文提出了一种无监督文本抽取摘要模型，相比于TextRank方法，PacSum主要做了两方面改进：</p><p>一是作者重新定义了句子中心性的计算方式，将句子之间的相对位置纳入了计算，改进了度中心性的计算方法。</p><p>二是通过BERT模型进行句子语义的捕获，这与文章提出时TextRank常采用的tf-idf在语义表示上有了提升（TextRank+BERT作者进行实验发现，效果比tf-idf要差，作者推测是因为TextRank模型错误的句子中心性导致的）</p><p>除此之外，作者基于句子分布假设，提出了与skip-thought vector不同的fine-tune方法，并取得了更好的效果。</p><p>作者在英文数据集、中文数据集进行了有无监督模型、有监督模型的实验，其中，取得了比文章提出时无监督模型更好的效果，并在英文数据集中，取得了与有监督模型十分相近的分数。</p><h3 id="1-Research-Objective-s"><a href="#1-Research-Objective-s" class="headerlink" title="1. Research Objective(s)"></a>1. <strong>Research Objective(s)</strong></h3><p>为了解决文本摘要领域，难以为不同类型的摘要、领域、语言去获得或创建大规模的高质量训练数据的问题，作者提出一个普遍适用的图排序算法，并且从两个方面改进了句子节点中心性计算：1)   基于BERT模型，捕捉句子语义 2) 使用有向边构建句子节点图，使用有向边，去表明任意两个句子的中心性分别被他们相对位置所造成的影响。</p><p>it is unrealistic to expect large-scale and high-quality training data to be available or created for different types of summaries, domains, or languages. Author revisit a popular graph-based ranking algorithm and modify how node (aka sentence) centrality is com- puted in two ways: (a) we employ BERT, a state-of-the-art neural representation learning model to better capture sentential meaning and (b) we build graphs with directed edges arguing that the contribution of any two nodes to their respective centrality is influenced by their relative position in a document.</p><h3 id="2-Background-Problem-Statement"><a href="#2-Background-Problem-Statement" class="headerlink" title="2. Background / Problem Statement"></a><strong>2. Background / Problem Statement</strong></h3><p><strong>背景：</strong></p><ul><li>基于神经网络的方法在成百上千的大规模数据集上取得了可观的效果</li></ul><p>Modern neural network-based approaches have achieved promising results thanks to the availability of large scale datasets containing hundreds of thousands of document-summary pairs</p><ul><li>大规模的、高质量的数据集难以创建或获得</li></ul><p>it is unrealistic to expect that large-scale and high-quality training data will be available or created for different summarization styles</p><ul><li>无监督方法是之前研究的重点，其中比较流行的是基于TextRank方法。</li></ul><p>A very popular algorithm for extractive single-document summarization is TextRank (Mihalcea and Tarau, 2004)</p><p><strong>问题阐述：</strong></p><ul><li>文本摘要领域，难以为不同类型的摘要、领域、语言去获得或创建大规模的高质量训练数据。</li></ul><p>it is unrealistic to expect that large-scale and high-quality training data will be available or created for different summarization styles</p><ul><li>无监督方法中，基于句子中心性的方式如TextRank可以从两方面改进，一是使用BERT模型获取文本语义，二是构建有向图来表示两个句子节点对相互之间的贡献是不同的</li></ul><p>We employ BERT (Devlin et al., 2018), a neural representation learn- ing model which has obtained state-of-the-art re- sults on various natural language processing tasks including textual inference, question answering, and sentiment analysis</p><p>we advocate that edges should be <em>directed</em>, since the contribu- tion induced by two nodes’ connection to their re- spective centrality can be in many cases unequal.</p><h3 id="3-Method-s"><a href="#3-Method-s" class="headerlink" title="3. Method(s)"></a>3. <strong>Method(s)</strong></h3><p><strong>3.1 句子中心性计算</strong></p><p><strong>3.1.1 无向图计算方法</strong></p><p>A node’s centrality can be measured by simply computing its degree or running a ranking algorithm such as PageRank</p><p>结点中心性计算可以简单的通过度计算，也可以通过排序算法，如PageRank。</p><p><strong>度中心性</strong>计算方法：<br>$$<br>centrality(si) = \sum_{j ∈{1,..,i−1,i+1,..,n}}{e_{ij}}<br>$$<br><strong>TextRank</strong>计算方法：</p><p>度中心性计算方法只考虑局部连通性，而PageRank算法通过递归为所有节点分配了相对的分数，与高得分节点相连接的节点对分数贡献更大。</p><p>Whereas degree centrality only takes local connectivity into account, PageRank assigns rela- tive scores to all nodes in the graph based on the recursive principle that connections to nodes hav- ing a high score contribute more to the score of the node in question.</p><p><strong>3.1.2 有向图计算方法</strong></p><p>理论支持：RST（Rhetorical Structure Theory），修辞结构理论，表示， 语篇单元重要性和显著性是不同的。根据其文本重要性，分为核心句与附属句。</p><p>The idea that textual units vary in terms of their importance or salience, has found support in various theories of discourse structure including Rhetorical Structure Theory.</p><p>in terms of their text importance: <em>nuclei</em> denote central segments, whereas <em>satellites</em> denote peripheral ones.</p><p>计算文本核心性的方法：通过文本的相对位置进行近似计算，其中，文档中出现较早的句子应该更核心。</p><p>We instead approximate nuclearity by relative position in the hope that sentences occurring earlier in a document should be more central.</p><p><strong>方法实现</strong></p><p>给定任意来自同篇文档的句子$s_i$，$s_j$：<br>$$<br>centrality(s_i) = \lambda_1\sum_{j&lt;i}{e_{ij}}  + \lambda_2\sum_{j&gt;i}{e_{ij}}<br>$$<br>其中，$\lambda_1$与$\lambda_2$表示前向句与后向句的有向边权重系数。</p><p> λ1, λ2 are different weights for forward- and backward-looking directed edges.</p><p>在实验中，我们设置$\lambda_1 + \lambda_2 = 1$控制超参数的数量</p><p>During tuning experiments, we set λ1 + λ2 = 1 to control the number of free hyper-parameters.</p><p>经过实验，我们发现前向系数$\lambda_1$趋向于负值，这表示与前面内容的相似性，实际上会损害其本身的中心性。</p><p>we find that the optimal λ1 tends to be negative, implying that similarity with previous content actually hurts centrality</p><p>未来可以通过PageRank等将负值边纳入计算。</p><p>Although it is possible to use some extensions of PageR- ank (Kerchove and Dooren, 2008) to take negative edges into account, we leave this to future work and only consider the definition of centrality from Equation (6) in this paper.</p><p><strong>3.2 语句相似度计算</strong></p><p>许多TextRank方法基于符号句表示（symbolic sentence representations）如tf-idf进行文本的表示。</p><p>There are many variations of the similarity function of TextRank (Barrios et al., 2016) based on symbolic sentence representations such as tf-idf.</p><p>本文采用一种神经网络分布式表示——BERT模型作为encoder，并通过一种句子级别分布假设对其进行fine-tune。</p><p>We use BERT (Devlin et al., 2018) as our sentence encoder and fine-tune it based on a type of sentence-level distributional hypothesis</p><p><strong>3.2.1 句子级分布式假设</strong></p><p>为了对BERT模型进行fine-tune，作者采用了一种句子级分布式假设来定义一个训练目标。</p><p>To fine-tune the BERT encoder, we exploit a type of sentence-level distributional hypothesis (Harris, 1954; Polajnar et al., 2015) as a means to define a training objective. </p><p>与通过重构编码句子的邻近句的Skip-thought vectors不同的是，作者借用了单词分布式假设的负采样方法。</p><p><strong>损失函数：</strong><br>$$<br>log\sigma({v^{‘}<em>{s</em>{i-1}}}^Tv_{s_{i}}) + log\sigma({v^{‘}<em>{s</em>{i+1}}}^Tv_{s_{i}}) + E_{s ̃p{(s)}}[log\sigma({-v^{‘}}^T{v_s})]<br>$$<br>其中 vs 和 vs′ 句子s在两个不同参数的BERT 编码器的不同表示， σ是sigmoud函数，P(s)是在句子空间定义的均匀分布。</p><p>where vs and vs′ are two different representa- tions of sentence s via two differently parameter- ized BERT encoders;， σ is the sigmoid function，and P (s) is a uniform distribution defined over the sentence space.</p><p>为了实现以上假设，作者为每个正样本，采取五个负样本。</p><p><strong>相似矩阵：</strong></p><p>一旦获得文档D的句子表示，作者采用成对求点积的方式来得到一个未标准化的相似矩阵：<br>$$<br>E^ ̄_{ij} =v_i^⊤v_j<br>$$<br>标准化：<br>$$<br>E^ ̃_{ij} = E^ ̄_{ij}−[minE^ ̄ +β(maxE^ ̄ − minE^ ̄)]<br>$$</p><p>$$<br>E_{ij}= E^ ̃_{ij}, \ if \ E^ ̃&gt;0 \ , \ else \ 0<br>$$</p><p>Equation (5) aims to remove the effect of absolute values by emphasizing the relative contribution of different similarity scores. This is particularly im- portant for the adopted sentence representations which in some cases might assign very high values to all possible sentence pairs. Hyper-parameter β (β ∈ [0, 1]) controls the threshold below which the similarity score is set to 0.</p><h3 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4. Evaluation"></a>4. <strong>Evaluation</strong></h3><p>数据集：NYT 与 CNN/Daily Mai，中文数据集TTNews</p><p>超参数：</p><ul><li>优化器：Adam</li><li>初始学习率：4e-6</li></ul><p>评价指标：</p><p>ROUGE-1、ROUGE-2、ROUGE-L</p><p>结果：</p><p>英文数据集，分别与SOTA有监督方法、无监督方法进行比较</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5i8qwpg0j31dg0oejx2.jpg" alt="image-20211106162215196"></p><p>超参数调优</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5ia3nrtmj30n60kwq4o.jpg" alt="image-20211106162335953"></p><p>中文数据集，与有监督、无监督方法进行对比的结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5ibp0dt1j30o60iiac8.jpg" alt="image-20211106162507741"></p><p>人工评测，通过构造QA，对生成的摘要内容进行人工评测的结果：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5iq6w6noj30mq08k3zb.jpg" alt="image-20211106163903788"></p><h3 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. <strong>Conclusion</strong></h3><p>作者提出的方法在三个数据集上都取得了比当前无监督文本抽取摘要基线模型更好的效果，并在英文数据集上取得了与有监督模型，如Pointer-generator相近的分数。</p><p>Experimental results on three news summarization datasets demonstrated the superiority of our approach against strong baselines.</p><p>未来，作者希望将本文提出的想法运用于有监督模型或者多文档摘要当中。</p><p>In the future, we would like to investigate whether some of the ideas introduced in this paper can improve the perfor- mance of supervised systems as well as sentence selection in multi-document summarization. </p><h3 id="6-Notes"><a href="#6-Notes" class="headerlink" title="6. Notes"></a>6. <strong>Notes</strong></h3><h3 id="7-References"><a href="#7-References" class="headerlink" title="7. References"></a>7. <strong>References</strong></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sentence-Centrality-Revisited-for-Unsupervised-Summarization（基于再访问句子中心性的无监督文本摘要生成）&quot;&gt;&lt;a href=&quot;#Sentence-Centrality-Revisited-for-Unsu</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>数学类型</title>
    <link href="http://booleanln.github.io/myblog/2021/10/16/%E6%95%B0%E5%AD%A6%E7%B1%BB%E5%9E%8B/"/>
    <id>http://booleanln.github.io/myblog/2021/10/16/%E6%95%B0%E5%AD%A6%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-10-16T15:38:57.000Z</published>
    <updated>2021-10-16T16:20:34.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>记录 <strong>“数学”</strong> 类型的题目：</p><h4 id="用-Rand7-实现-Rand10"><a href="#用-Rand7-实现-Rand10" class="headerlink" title="用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">用 Rand7() 实现 Rand10()</a></h4><p>已有方法 <code>rand7</code> 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 1 到 10 范围内的均匀随机整数。</p><p>思路：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token keyword">extends</span> <span class="token class-name">SolBase</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rand10</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> first<span class="token punctuation">,</span> second<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>first <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>second <span class="token operator">=</span> <span class="token function">rand7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> first <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> second <span class="token operator">:</span> <span class="token number">5</span> <span class="token operator">+</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数学&quot;&gt;&lt;a href=&quot;#数学&quot; class=&quot;headerlink&quot; title=&quot;数学&quot;&gt;&lt;/a&gt;数学&lt;/h3&gt;&lt;p&gt;记录 &lt;strong&gt;“数学”&lt;/strong&gt; 类型的题目：&lt;/p&gt;
&lt;h4 id=&quot;用-Rand7-实现-Rand10&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="数学" scheme="http://booleanln.github.io/myblog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>云原生</title>
    <link href="http://booleanln.github.io/myblog/2021/10/15/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    <id>http://booleanln.github.io/myblog/2021/10/15/%E4%BA%91%E5%8E%9F%E7%94%9F/</id>
    <published>2021-10-15T07:07:54.000Z</published>
    <updated>2021-10-15T09:08:10.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvg0gzt30zj61ig0p8tb202.jpg" alt="image-20211015150816950"></p><h4 id="什么叫云原生？"><a href="#什么叫云原生？" class="headerlink" title="什么叫云原生？"></a>什么叫云原生？</h4><p>CloudNative，<strong>云原生</strong>其实是一种构建和运行应用程序的方法，Cloud表示一切应用都在云上，Native表示应用程序从设计之初就是基于云的概念。</p><p>云原生包括四个要点：DevOps + 持续交付 + 微服务 + 容器化</p><p><strong>DevOps</strong>：开发流程与运维流程合体，为云原生提供持续交付能力</p><p><strong>持续交付</strong>：不误时开发、不停机更新，小步快跑，反传统瀑布式开发模型。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvg3xoboboj611i0lw76u02.jpg" alt="image-20211015170808475"></p><h4 id="为什么需要云原生？"><a href="#为什么需要云原生？" class="headerlink" title="为什么需要云原生？"></a>为什么需要云原生？</h4><h4 id="如何使用云原生进行开发？"><a href="#如何使用云原生进行开发？" class="headerlink" title="如何使用云原生进行开发？"></a>如何使用云原生进行开发？</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;云原生&quot;&gt;&lt;a href=&quot;#云原生&quot; class=&quot;headerlink&quot; title=&quot;云原生&quot;&gt;&lt;/a&gt;云原生&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/008i3skNgy1gvg0gzt30zj61ig</summary>
      
    
    
    
    
    <category term="cloud" scheme="http://booleanln.github.io/myblog/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Introduction to Graph Neural Networks</title>
    <link href="http://booleanln.github.io/myblog/2021/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Introduction-to-Graph-Neural-Networks/"/>
    <id>http://booleanln.github.io/myblog/2021/10/13/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Introduction-to-Graph-Neural-Networks/</id>
    <published>2021-10-13T12:52:43.000Z</published>
    <updated>2021-10-17T08:30:41.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction-to-Graph-Neural-Networks"><a href="#Introduction-to-Graph-Neural-Networks" class="headerlink" title="Introduction to Graph Neural Networks"></a>Introduction to Graph Neural Networks</h3><h4 id="为什么需要GNN"><a href="#为什么需要GNN" class="headerlink" title="为什么需要GNN"></a>为什么需要GNN</h4><p>不同预训练模型集成</p><p>数据增强</p><p>大模型</p><p>ATEC、微软句法结构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Introduction-to-Graph-Neural-Networks&quot;&gt;&lt;a href=&quot;#Introduction-to-Graph-Neural-Networks&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Gr</summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读-Evolution of Semantic Similarity—A Survey</title>
    <link href="http://booleanln.github.io/myblog/2021/10/11/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Evolution-of-Semantic-Similarity%E2%80%94A-Survey/"/>
    <id>http://booleanln.github.io/myblog/2021/10/11/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Evolution-of-Semantic-Similarity%E2%80%94A-Survey/</id>
    <published>2021-10-11T09:19:04.000Z</published>
    <updated>2021-10-13T12:26:05.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Evolution-of-Semantic-Similarity—A-Survey"><a href="#Evolution-of-Semantic-Similarity—A-Survey" class="headerlink" title="Evolution of Semantic Similarity—A Survey"></a>Evolution of Semantic Similarity—A Survey</h4><p>语义相似模型分为：</p><ul><li>knowledgebased， 基于知识</li><li>corpus-based, 基于语料库</li><li>deep neural network–based methods， 基于深度神经网络</li><li>hybrid methods， 混合方法</li></ul><p>Semantic Textual Similarity （STS）主要给出两段文本的相似度排名或百分比。</p><p>下图为文章介绍的相关模型</p><p><img src="/Users/jiayi/Library/Application%20Support/typora-user-images/image-20211011173454520.png" alt="image-20211011173454520"></p><h5 id="基于知识的模型"><a href="#基于知识的模型" class="headerlink" title="基于知识的模型"></a>基于知识的模型</h5><p>基于知识的方法计算两个术语之间的语义相似度基于一个或多个知识库，如本体/词汇数据库，叙词表，词典等。</p><p>常用的知识库一般是词汇数据库lexical databases：</p><ul><li><p>WordNet：wordNet用node代表词义，并通过edge定义词之间的关系，两个词之间的相似度，取决于它们之间的距离。</p></li><li><p>Wikipedia：基于Wikipedia，每个词组都有一个文章页面与之相关联，每篇文章同时具有标题、neighbors、描述和分类，这些作为特征都可以用于相似性的计算。</p></li><li><p>BabelNet：babelNet是一个集合了WordnNet以及Wikipedia的词汇数据库</p></li></ul><p>基于知识模型方法主要包括以下类型：</p><ul><li><p>Edge-counting 边计数法</p><p><em>Path</em>方法：</p><p>​    将词抽象为图节点，根据词的分类将两个词连接起来，然后统计边的数量作为两个term的相似度。<br>$$<br>sim_{path} (t1,t2) = \frac{1}{1 + min_len(t1,t2)}<br>$$</p><p><em>wup</em>方法：</p><p>​    该方法统计每个term自身的分类深度，以及两个term（Least Common Subsumer）最近祖先分类点的深度：<br>$$<br>sim_{wup} (t_1,t_2) = \frac{2depth(t_{lcs})}{depth(t_1) + depth(t_2)}<br>$$<br>​    </p><p>缺点：忽略了本体中的edges不必等长的事实</p></li><li><p>Feature-based 特征法</p><p>基于词汇的属性，如注解、相似概念等，进行相似度的计算。</p><p><em>Lesk</em>：衡量两个词的相似度，主要考虑两个词的注解以及在WordNet中表示该词含义的词的注解的overlap</p></li><li><p>Information Content-based 基于信息内容的方法</p></li><li><p>Combined Knowledge-based </p></li></ul><h5 id="基于语料库的STS"><a href="#基于语料库的STS" class="headerlink" title="基于语料库的STS"></a>基于语料库的STS</h5><p>基于语料库的方法根据从大规模的语料库中抽取出的信息，来衡量两个term之间的相似度。词的实际意义并没有被作为依据，而是基于一种”分布假设”，即相似的词语出现在一起 “similar words occur together, frequently”。</p><p>基于分布假设，出现了很多techniques，来构建文本数据的向量表示。</p><p>词嵌入提供了词的向量表示，在向量中，保持了词语之间的语义关系，常见的词嵌入包括：</p><ul><li><em>word2vec</em></li><li><em>GloVe</em></li><li><em>fastText</em></li><li><em>BERT</em></li></ul><p>在使用词嵌入作为相似度的衡量标准时，不可避免地会遇到“ Meaning Conflation Deficiency”词融合缺陷，举个例子，”finance”与”river”在语义空间中的位置很近，因为它们的一个相关词“bank”具备多重含义。</p><p>关键是要认识到，词嵌入本身是基于大规模语料库的，因此它的分布假设等与采取的语料库息息相关。</p><ol><li>基于语料库的方法：<ul><li>LSA（Latent Semantic Analysis）</li><li>HAL（Hyperspace Analogue to Language）</li><li>ESA（Explicit Semantic Analysis）</li><li>Word-alignment Models</li><li>LDA（Latent Dirichlet Allocation）</li><li>Normalized Google Distance </li><li>Dependency-based Models</li><li>Kernel-based Models</li><li>Word-attention Models</li></ul></li></ol><h5 id="深度神经网络方法"><a href="#深度神经网络方法" class="headerlink" title="深度神经网络方法"></a>深度神经网络方法</h5><ul><li>DAM（Decomposable Attention Model）</li><li>Transformer-based models</li></ul><h5 id="混合方法Hybrid"><a href="#混合方法Hybrid" class="headerlink" title="混合方法Hybrid"></a>混合方法Hybrid</h5><ul><li>NASARI</li><li>MSSA</li><li>UESTS</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Evolution-of-Semantic-Similarity—A-Survey&quot;&gt;&lt;a href=&quot;#Evolution-of-Semantic-Similarity—A-Survey&quot; class=&quot;headerlink&quot; title=&quot;Evolution </summary>
      
    
    
    
    
    <category term="论文" scheme="http://booleanln.github.io/myblog/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题</title>
    <link href="http://booleanln.github.io/myblog/2021/07/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://booleanln.github.io/myblog/2021/07/21/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-07-21T05:22:58.000Z</published>
    <updated>2021-09-09T03:01:03.009Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java面试题集锦"><a href="#Java面试题集锦" class="headerlink" title="Java面试题集锦"></a>Java面试题集锦</h4><h5 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h5><ol><li><p>介绍ArrayList底层实现</p><p>ArrayList底层通过Object数组实现，可以指定<code>capacity</code>参数，设置容量大小，默认容量是10。</p><p>当添加元素时，会进行空间大小的判定，当容量不够时，执行自动扩容算法。</p><p>在扩容算法中，默认扩大到当前长度的1.5倍，如果扩大后大小仍无法满足要求，则将其设置为所需大小，超出最大值，则设置为<code>Integer.MAX_VALUE</code>。</p><p>支持元素随机访问，末尾插入数据O（1），特定位置插入元素O（n-i）</p></li><li><p>介绍LinkedList底层实现</p><p>LinkedList底层通过一个Node双向链表实现。首尾插入删除元素复杂度为O(1)，特定位置插入删除元素复杂度为O(n)</p></li><li><p>介绍HashMap</p><p>HashMap，一种Hash数据结构，底层通过数组，链表以及红黑树实现：</p><p>整体构建<code> Node&lt;K,V&gt;[] table</code>，存储Node，当发生Hash冲突时，采取链地址法进行解决，当链较长，达到设定的转树阈值，链表会转为红黑树。</p><ul><li>Node&lt;K,V&gt;链表</li><li>TreeNode&lt;K,V&gt;，红黑树结构</li></ul><p>HashMap扩容机制：</p><p>HashMap默认容量为16，</p><ol><li>未初始化Map，会先对Map进行扩容</li><li>已初始化Map，将元素加入Map当中，当添加的元素达到转树的阈值后，会将链表转为红黑树</li></ol><p>之后，判断加入的元素总和超过设定好的阈值<code>capacity * load factor</code>，触发<code>resize</code>，开始扩容，扩容为原来的2倍大小。扩容时，会新建一个hash结构，新的位置要么在原位置，要么在原长度+原坐标。</p></li><li><p>HashMap1.7与1.8之间的差异</p><p>jdk1.7中，采用数组+链表方式，1.8中添加了红黑树，优化了查询效率</p><p>jdk1.7中，链表是采用头插法，1.8中采取尾插法</p><p>jdk1.8优化了hash算法，只需要一次扰动</p><p>jdk1.8中rehash，通过e.hash &amp; oldCap==0来判断新插入的位置是否为原位置，jdk1.7则需要重新计算hash位置，并采用头插法，会有并发问题。</p><p>jdk1.8中，table是懒加载，在第一次putVal时触发扩容进行创建</p></li><li><p>介绍ConcurrentHashMap</p><p>线程安全的HashMap，1.7中，底层通过<strong>分段的数组+链表</strong>实现，将数据分为若干段，每段加一把锁。1.8中，使用<code>sychronized关键字</code>以及<code>CAS</code>乐观锁实现。</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。扩容操作可以并发。</p></li><li><p>HashSet与HashMap异同</p></li><li><p>HashMap与TreeMap实现原理</p><p>TreeMap提供了对键值的排序功能，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。TreeMap基于红黑树实现。</p></li></ol><h5 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h5><h5 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h5><ol><li><p>JVM内存区域</p><p>JVM内存区域包括堆区（存储对象信息，GC）、虚拟机栈区（存放局部变量表、操作数、动态链接、返回地址表等构成栈帧）、程序计数器（代码执行位置指示器）、本地方法栈（Native方法的栈）、元空间（存放类信息，方法信息）、直接内存。</p><p>其中堆、元空间（方法区）、直接内存是线程共享的，其他为线程私有的。</p></li><li><p>String常量池介绍</p></li><li><p>会发生OOM的区域</p><p>堆、虚拟机栈、本地方法栈、元空间</p></li><li><p>类加载过程</p><p>加载、验证、准备、解析、初始化。</p><p>首先，获取类文件的二进制字节流，在堆中生成一个代表类的Class对象，作为方法区的这些数据的访问入口。</p><p>验证阶段主要是对文件格式、字节码等进行验证，该阶段会穿插在各阶段中，准备阶段主要为类变量分配空间。</p></li><li><p>双亲委派机制</p><p>jvm提供了三类ClassLoader，分别是Bootstrap ClassLoader、ExtClassLoader、ApplicationClassLoader，分别加载核心类库（java、javax、sun开头）、扩展类库、应用ClassPath下的类。</p><p>当需要对一个类进行加载时，首先查看当前类在本加载器上是否已加载，否则层层向上进行委派，直到Bootstrap ClassLoader，如果父类加载器无法完成加载，再向下层层委派，进行加载。</p><p>优点：避免重复加载，保证核心类不被篡改替换。</p></li><li><p>对象创建过程</p><p>类加载检查-&gt;分配内存-&gt; 初始化零值-&gt;设置对象头-&gt;执行init方法</p></li><li><p>对象内存布局</p><p>对象头、实例数据以及对齐填充。</p><p>对象头包括分代年龄、锁标志、hashcode、元数据指针等</p></li><li><p>对象访问定位</p><p>句柄池、直接访问。</p></li><li><p>String s1 = new String(“abc”);这句话创建了几个字符串对象？</p><ul><li><p>1个，一个s1的字符串对象，指向常量池中的“abc”</p></li><li><p>两个，先在常量池创建一个“abc”字面量，一个s1的字符串对象，指向常量池中的“abc”</p></li></ul></li><li><p>垃圾回收算法</p></li><li><p>讲讲CMS</p></li><li><p>讲讲G1</p></li></ol><h5 id="基础考察"><a href="#基础考察" class="headerlink" title="基础考察"></a>基础考察</h5><ol><li><p>==与equals的关系</p><p>基本类型==比较的是值，非基本类型==比较的是两个在内存中存放的地址</p><p>equals如果没有被重写，则比较的是地址，如果被重写了，则比较的是地址中的内容</p></li><li><p>equals与hashcode为什么要同时重写</p><p>主要是考虑当一个对象需要在散列表中存储时，如果两个对象通过equals比较是相同的，那么表示其是相同的对象，那么在Hash结构中，必须保证它们得到的hashcode是一样的。</p></li><li><p>拆箱与装箱</p></li></ol><p>12345@Yw</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Java面试题集锦&quot;&gt;&lt;a href=&quot;#Java面试题集锦&quot; class=&quot;headerlink&quot; title=&quot;Java面试题集锦&quot;&gt;&lt;/a&gt;Java面试题集锦&lt;/h4&gt;&lt;h5 id=&quot;容器相关&quot;&gt;&lt;a href=&quot;#容器相关&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Java" scheme="http://booleanln.github.io/myblog/tags/Java/"/>
    
    <category term="面试" scheme="http://booleanln.github.io/myblog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GC调优实践-内存泄漏排查</title>
    <link href="http://booleanln.github.io/myblog/2021/07/16/GC%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/"/>
    <id>http://booleanln.github.io/myblog/2021/07/16/GC%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5/</id>
    <published>2021-07-16T07:05:43.000Z</published>
    <updated>2021-10-23T06:23:40.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GC调优实践-内存泄漏排查"><a href="#GC调优实践-内存泄漏排查" class="headerlink" title="GC调优实践-内存泄漏排查"></a>GC调优实践-内存泄漏排查</h3><p>看到一篇内存泄漏的文章，动手实践了下。</p><p><strong>场景说明</strong></p><p>使用<code>HttpAsyncClient</code>库，访问10000次某一个url，并</p><p>设置JVM参数：</p><pre class="line-numbers language-none"><code class="language-none">-XX:+PrintGCDetails -Xloggc:&#x2F;Users&#x2F;jiayi&#x2F;seckill&#x2F;logs&#x2F;gc&#x2F;gcc.log -Xmx200m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打印出的日志：</p><pre class="line-numbers language-none"><code class="language-none">229.449: [GC (Allocation Failure) [PSYoungGen: 30720K-&gt;2048K(31232K)] 164715K-&gt;137644K(167936K), 0.0014919 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] 246.484: [Full GC (Ergonomics) [PSYoungGen: 28160K-&gt;3189K(30720K)] [ParOldGen: 136334K-&gt;136334K(136704K)] 164494K-&gt;139524K(167424K), [Metaspace: 15467K-&gt;15467K(1062912K)], 0.0435582 secs] [Times: user&#x3D;0.35 sys&#x3D;0.00, real&#x3D;0.05 secs] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>触发了多次Full GC后，程序最终因<code>Exception in thread &quot;I/O dispatcher 1&quot; java.lang.OutOfMemoryError: Java heap space</code>崩溃。</p><p>通过VisualVM对程序进行监控：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsitq8c3ooj30uo0u0qao.jpg" alt="image-20210716153039219" style="zoom:50%;" /><p>可以看到，老年代的内存一直在增加。</p><p>由以上内容，我们可以猜测是某些对象，因为没有及时释放，导致无法被回收。按照代码来说，我们只涉及到一个<code>HttpUriRequest</code>的对象列表，老年代应该不会一直增加。</p><p>但是通过查看<code>HttpClientAsyncService</code>的内存占用情况，<code>HttpClientAsyncService$1</code>一直处于上升状态，肯定是这块代码有了问题。<code>HttpClientAsyncService$1</code>表示<code>HttpClientAsyncService</code>的内部类，从代码中，我们可以得知是<code>FutureCallback</code>匿名内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpUriRequest</span><span class="token punctuation">></span></span> <span class="token function">loadMockRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpUriRequest</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpGet</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com?a="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// cache.add("http://www.baidu.com?a=" + i);</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> cache<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpUriRequest</span><span class="token punctuation">></span></span> cache<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token class-name">CloseableHttpAsyncClient</span> client <span class="token operator">=</span> <span class="token class-name">HttpAsyncClients</span><span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// String url = cache.get(i%cache.size());</span>            <span class="token comment">// final HttpGet request = new HttpGet(url);</span>            <span class="token class-name">HttpUriRequest</span> request <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">%</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FutureCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HttpResponse</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">HttpResponse</span> httpResponse<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// System.out.println(request.getRequestLine() + "->" + httpResponse.getStatusLine());</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// System.out.println(request.getRequestLine() + "->" + e);</span>                <span class="token punctuation">&#125;</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">//  System.out.println(request.getRequestLine() + " cancelled");</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是出现内存泄漏的代码部分，对这块代码进行Debug，我们发现了以下结果：</p><p>在Client执行请求时，会将<code>FutureCallback</code>构建<code>Future</code>对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BasicFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicFuture</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该对象会参与<code>DefaultClientExchangeHandlerImpl</code>的构建：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DefaultClientExchangeHandlerImpl</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultClientExchangeHandlerImpl</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>log<span class="token punctuation">,</span> requestProducer<span class="token punctuation">,</span> responseConsumer<span class="token punctuation">,</span> localcontext<span class="token punctuation">,</span> future<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>connmgr<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>connReuseStrategy<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keepaliveStrategy<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>exec<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后，handler调用<code>start</code>方法，其中，会将整个handler设置在请求里面</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HttpRequest</span> original <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>requestProducer<span class="token punctuation">.</span><span class="token function">generateRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HttpExecutionAware</span><span class="token punctuation">)</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCancellable</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这也导致了前面构建的匿名内部类被存在请求里面，因为我们的请求是存在集合当中的，没有办法及时释放，随着Young GC，内部类晋升至Old Gen，最终将老年代空间挤爆。</p><p><strong>解决办法</strong></p><p>使用基本数据类型构建缓存，随时释放请求类，也就释放了内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">loadMockRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com?a="</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> cache<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GC调优实践-内存泄漏排查&quot;&gt;&lt;a href=&quot;#GC调优实践-内存泄漏排查&quot; class=&quot;headerlink&quot; title=&quot;GC调优实践-内存泄漏排查&quot;&gt;&lt;/a&gt;GC调优实践-内存泄漏排查&lt;/h3&gt;&lt;p&gt;看到一篇内存泄漏的文章，动手实践了下。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="Java" scheme="http://booleanln.github.io/myblog/tags/Java/"/>
    
    <category term="GC调优" scheme="http://booleanln.github.io/myblog/tags/GC%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ如何保证顺序消费</title>
    <link href="http://booleanln.github.io/myblog/2021/07/09/RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/"/>
    <id>http://booleanln.github.io/myblog/2021/07/09/RocketMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9/</id>
    <published>2021-07-09T01:08:08.000Z</published>
    <updated>2021-07-09T01:08:08.733Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://booleanln.github.io/myblog/2021/07/03/%E8%B4%AA%E5%BF%83/"/>
    <id>http://booleanln.github.io/myblog/2021/07/03/%E8%B4%AA%E5%BF%83/</id>
    <published>2021-07-03T11:58:45.000Z</published>
    <updated>2021-07-08T07:16:33.607Z</updated>
    
    <content type="html"><![CDATA[<h4 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h4><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>思路：</p><ol><li>一开始的思路是先按照<code>ki</code>值进行排序，然后，从0～n，按个去放：放第0个位置时，肯定是从<code>k=0</code>的去选，按照贪心原则选择最小的，其次，需要判断前面的数字是否满足ki个大于当前hi的，满足就放在优先队列，每一轮，取出一个，但这样的复杂度太高，O(n<em>n</em>logn)</li><li>看了题解的思路，如下：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reconstructQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> people<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 身高从小到大排，如果身高相同，则按照k从大到小排序</span>        <span class="token comment">// 本解题思路是从小到大，将其前面的空预留，比如[4,4]，那么在它前面预留4个位置，把它放在第五个位置，</span>        <span class="token comment">// 当[6,1]时，前面需要预留一个空位置，忽视小于6的，预留一个空位置即可</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token punctuation">(</span>person1<span class="token punctuation">,</span> person2<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>person1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> person2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> person1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> person2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> person2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> person1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> people<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> person<span class="token operator">:</span>people<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> spaces <span class="token operator">=</span> person<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    spaces<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>spaces <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> person<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>思路：</p><ol><li><p>动态规划：</p><p>本题考虑到n的完全平方数f(n)，与<code>f(n-k)+1</code>有关，也就是与子状态相关，考虑使用DP。</p><p>$f(n) = Math.min(f(n-k) + 1),k=1,4,9,16…$</p><p>时间复杂度为$O(n\sqrt{n})$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>tmp<span class="token operator">*</span>tmp <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token operator">*</span>tmp <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>tmp<span class="token operator">*</span>tmp<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>贪心算法</p><p>需要的数目从1到n，去判断能否组成，需要预设完全平方数列表。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> nums<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">*</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token operator">*</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>n<span class="token operator">-</span>num<span class="token punctuation">,</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;根据身高重建队列&quot;&gt;&lt;a href=&quot;#根据身高重建队列&quot; class=&quot;headerlink&quot; title=&quot;根据身高重建队列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/queue-reconstruction</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://booleanln.github.io/myblog/tags/leetcode/"/>
    
    <category term="贪心" scheme="http://booleanln.github.io/myblog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>高并发下的商品详情页</title>
    <link href="http://booleanln.github.io/myblog/2021/07/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5/"/>
    <id>http://booleanln.github.io/myblog/2021/07/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5/</id>
    <published>2021-07-01T07:12:42.000Z</published>
    <updated>2021-07-01T07:18:46.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高并发下的商品详情页"><a href="#高并发下的商品详情页" class="headerlink" title="高并发下的商品详情页"></a>高并发下的商品详情页</h3><p>如何保证高并发下商品详情页的正常访问？</p><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><h4 id="全页面静态化"><a href="#全页面静态化" class="headerlink" title="全页面静态化"></a>全页面静态化</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;高并发下的商品详情页&quot;&gt;&lt;a href=&quot;#高并发下的商品详情页&quot; class=&quot;headerlink&quot; title=&quot;高并发下的商品详情页&quot;&gt;&lt;/a&gt;高并发下的商品详情页&lt;/h3&gt;&lt;p&gt;如何保证高并发下商品详情页的正常访问？&lt;/p&gt;
&lt;h4 id=&quot;多级缓存&quot;&gt;</summary>
      
    
    
    
    
    <category term="项目" scheme="http://booleanln.github.io/myblog/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="高并发" scheme="http://booleanln.github.io/myblog/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发下扣库存策略</title>
    <link href="http://booleanln.github.io/myblog/2021/06/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%89%A3%E5%BA%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://booleanln.github.io/myblog/2021/06/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E6%89%A3%E5%BA%93%E5%AD%98%E7%AD%96%E7%95%A5/</id>
    <published>2021-06-29T09:47:29.000Z</published>
    <updated>2021-07-01T07:49:18.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高并发下如何正确地扣减库存"><a href="#高并发下如何正确地扣减库存" class="headerlink" title="高并发下如何正确地扣减库存"></a>高并发下如何正确地扣减库存</h3><h4 id="库存缓存"><a href="#库存缓存" class="headerlink" title="库存缓存"></a>库存缓存</h4><h4 id="异步事务消息回写数据库"><a href="#异步事务消息回写数据库" class="headerlink" title="异步事务消息回写数据库"></a>异步事务消息回写数据库</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;高并发下如何正确地扣减库存&quot;&gt;&lt;a href=&quot;#高并发下如何正确地扣减库存&quot; class=&quot;headerlink&quot; title=&quot;高并发下如何正确地扣减库存&quot;&gt;&lt;/a&gt;高并发下如何正确地扣减库存&lt;/h3&gt;&lt;h4 id=&quot;库存缓存&quot;&gt;&lt;a href=&quot;#库存缓存&quot;</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://booleanln.github.io/myblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="项目" scheme="http://booleanln.github.io/myblog/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
</feed>
